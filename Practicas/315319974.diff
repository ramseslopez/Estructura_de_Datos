diff --git a/src/mx/unam/ciencias/edd/ArbolAVL.java b/src/mx/unam/ciencias/edd/ArbolAVL.java
index 43c2127..c5f0239 100644
--- a/src/mx/unam/ciencias/edd/ArbolAVL.java
+++ b/src/mx/unam/ciencias/edd/ArbolAVL.java
@@ -6,8 +6,7 @@ package mx.unam.ciencias.edd;
  * <p>Un árbol AVL cumple que para cada uno de sus vértices, la diferencia entre
  * la áltura de sus subárboles izquierdo y derecho está entre -1 y 1.</p>
  */
-public class ArbolAVL<T extends Comparable<T>>
-    extends ArbolBinarioOrdenado<T> {
+public class ArbolAVL<T extends Comparable<T>> extends ArbolBinarioOrdenado<T> {
 
     /**
      * Clase interna protegida para vértices de árboles AVL. La única diferencia
@@ -24,7 +23,8 @@ public class ArbolAVL<T extends Comparable<T>>
          * @param elemento el elemento del vértice.
          */
         public VerticeAVL(T elemento) {
-            // Aquí va su código.
+            super(elemento);
+            altura = 0;
         }
 
         /**
@@ -32,7 +32,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            // Aquí va su código.
+            return altura;
         }
 
         /**
@@ -40,7 +40,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * @return una representación en cadena del vértice AVL.
          */
         @Override public String toString() {
-            // Aquí va su código.
+            return elemento + " " + this.altura + "/" + obtenerBalance(this);
         }
 
         /**
@@ -56,8 +56,8 @@ public class ArbolAVL<T extends Comparable<T>>
         @Override public boolean equals(Object o) {
             if (o == null || getClass() != o.getClass())
                 return false;
-            @SuppressWarnings("unchecked") VerticeAVL vertice = (VerticeAVL)o;
-            // Aquí va su código.
+            @SuppressWarnings("unchecked") VerticeAVL vertice = ( VerticeAVL)o;
+            return altura == vertice.altura && super.equals(o);
         }
     }
 
@@ -66,7 +66,7 @@ public class ArbolAVL<T extends Comparable<T>>
      * de {@link ArbolBinarioOrdenado}.
      */
     public ArbolAVL() {
-        // Aquí va su código.
+	super();
     }
 
     /**
@@ -75,7 +75,7 @@ public class ArbolAVL<T extends Comparable<T>>
      * @param coleccion la colección a partir de la cual creamos el árbol AVL.
      */
     public ArbolAVL(Coleccion<T> coleccion) {
-        // Aquí va su código.
+        super(coleccion);
     }
 
     /**
@@ -94,7 +94,31 @@ public class ArbolAVL<T extends Comparable<T>>
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        super.agrega(elemento);
+        rebalanceaAVL(verticeAVL(ultimoAgregado));
+    }
+
+    /**
+     * Metodo para rebalancear el ArbolAVL
+     * @param vertice vertice a agregar o eliminar
+     */
+    private void rebalanceaAVL(VerticeAVL vertice){
+        if (vertice == null) {
+            return;
+        }
+        vertice.altura = getAltura(vertice);
+        if (obtenerBalance(vertice) == -2) {
+            if (obtenerBalance(verticeAVL(vertice.izquierdo)) == 1) {
+                aLaDerecha(verticeAVL(vertice.izquierdo));
+            }
+            aLaIzquierda(vertice);
+        } else if (obtenerBalance(vertice) == 2) {
+            if (obtenerBalance(verticeAVL(vertice.izquierdo)) == -1) {
+                aLaIzquierda(verticeAVL(vertice.izquierdo));
+            }
+            aLaDerecha(vertice);
+        }
+        rebalanceaAVL(verticeAVL(vertice.padre));
     }
 
     /**
@@ -103,10 +127,137 @@ public class ArbolAVL<T extends Comparable<T>>
      * @param elemento el elemento a eliminar del árbol.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+      Vertice eliminar = busca(raiz, elemento), vi;
+        if (eliminar == null) {
+            return;
+        }
+        if (eliminar.hayIzquierdo()) {
+            vi = eliminar;
+            eliminar = maximoEnSubarbol(eliminar.izquierdo);
+            vi.elemento = eliminar.elemento;
+        }
+
+        if (!eliminar.hayIzquierdo() && !eliminar.hayDerecho()) {
+            eliminaHoja(eliminar);
+        } else if (!eliminar.hayIzquierdo()) {
+            eliminaSinHijoIzquierdo(eliminar);
+        } else {
+            eliminaSinHijoDerecho(eliminar);
+        }
+        rebalanceaAVL(verticeAVL(eliminar.padre));
+    }
+
+    /**
+     * Metodo para obtener el balance de un vertice
+     * @param vertice vertice actual
+     * @return int - balance del vertice
+     */
+    private int obtenerBalance(VerticeAVL vertice){
+        if (vertice == null) {
+            return 0;
+        } else {
+            return getAltura(verticeAVL(vertice.izquierdo)) - getAltura(verticeAVL(vertice.derecho));
+        }
     }
 
     /**
+     * Metodo para obtenr la altura de un vertice
+     * @param vertice vertice actual
+     * @return int - altura del vertice
+     */
+    private int getAltura(VerticeAVL vertice){
+      if(vertice == null){
+        return -1;
+      }
+      return 1 + Math.max(getAltura(verticeAVL(vertice.izquierdo)), getAltura(verticeAVL(vertice.derecho)));
+    }
+
+    /**
+     * Metodo para girar un vertice a la derecha
+     * @param vertice vertice sobre el cual se va a girar
+     */
+     private void aLaDerecha(VerticeAVL vertice){
+         super.giraDerecha(vertice);
+         vertice.altura = getAltura(vertice);
+         verticeAVL(vertice.padre).altura = getAltura(verticeAVL(vertice.padre));
+     }
+
+     /**
+      * Metodo para girar un vertice a la izquierda
+      * @param vertice vertice sobre el cual se va a girar
+      */
+      private void aLaIzquierda(VerticeAVL vertice){
+          super.giraIzquierda(vertice);
+          vertice.altura = getAltura(vertice);
+          verticeAVL(vertice.padre).altura = getAltura(verticeAVL(vertice.padre));
+      }
+
+      /**
+       * Metodo para subir al hijo de un vertice
+       * @param vertice vertice actual
+       */
+       private void subirHijo(VerticeAVL vertice){
+           if (!vertice.hayIzquierdo()) {
+               eliminaSinHijoIzquierdo(vertice);
+           } else {
+             eliminaSinHijoDerecho(vertice);
+           }
+       }
+
+       /**
+        * Auxiliar de elimina. Elimina una hoja.
+        * @param vertice el elemento a eliminar que debe ser hoja.
+        */
+       private void eliminaHoja(VerticeAVL vertice) {
+           if (raiz == vertice) {
+               raiz = ultimoAgregado = null;
+           } else if (hijoIzquierdo(vertice)) {
+               vertice.padre.izquierdo = null;
+           } else {
+               vertice.padre.derecho = null;
+           }
+           elementos--;
+       }
+
+       /**
+        * Auxiliar de elimina. Elimina vertice que no tiene hijo izquierdo.
+        * @param v el elemento a eliminar que debe no tener hijo izquierdo.
+        */
+       protected void eliminaSinHijoIzquierdo(VerticeAVL v) {
+           if (raiz == v) {
+               raiz = raiz.derecho;
+               v.derecho.padre = null;
+           } else {
+               v.derecho.padre = v.padre;
+               if (hijoIzquierdo(v)) {
+                   v.padre.izquierdo = v.derecho;
+               } else {
+                   v.padre.derecho = v.derecho;
+               }
+           }
+           elementos--;
+       }
+
+       /**
+        * Auxiliar de elimina. Elimina vertice que no tiene hijo derecho.
+        * @param v el elemento a eliminar que debe no tener hijo derecho.
+        */
+       protected void eliminaSinHijoDerecho(VerticeAVL v) {
+           if (raiz == v) {
+               raiz = raiz.izquierdo;
+               v.izquierdo.padre = null;
+           } else {
+               v.izquierdo.padre = v.padre;
+               if (hijoIzquierdo(v)) {
+                   v.padre.izquierdo = v.izquierdo;
+               } else {
+                   v.padre.derecho = v.izquierdo;
+               }
+           }
+           elementos--;
+       }
+
+    /**
      * Lanza la excepción {@link UnsupportedOperationException}: los árboles AVL
      * no pueden ser girados a la derecha por los usuarios de la clase, porque
      * se desbalancean.
@@ -131,4 +282,14 @@ public class ArbolAVL<T extends Comparable<T>>
                                                 "girar a la derecha por el " +
                                                 "usuario.");
     }
+
+    /**
+     * Metodo para convertir un VerticeArbolBinario en VerticeAVL
+     * @param vertice vertice a convertir
+     * @return VerticeAVL - vertice convertido
+     */
+     private VerticeAVL verticeAVL(VerticeArbolBinario<T> vertice){
+         VerticeAVL v = (VerticeAVL)vertice;
+         return v;
+     }
 }
diff --git a/src/mx/unam/ciencias/edd/ArbolBinario.java b/src/mx/unam/ciencias/edd/ArbolBinario.java
index f3294f8..c482ca5 100644
--- a/src/mx/unam/ciencias/edd/ArbolBinario.java
+++ b/src/mx/unam/ciencias/edd/ArbolBinario.java
@@ -1,4 +1,4 @@
-package mx.unam.ciencias.edd;
+ package mx.unam.ciencias.edd;
 
 import java.util.NoSuchElementException;
 
@@ -29,7 +29,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @param elemento el elemento del vértice.
          */
         public Vertice(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
         }
 
         /**
@@ -38,7 +38,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayPadre() {
-            // Aquí va su código.
+            return padre != null;
         }
 
         /**
@@ -47,7 +47,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayIzquierdo() {
-            // Aquí va su código.
+            return izquierdo != null;
         }
 
         /**
@@ -56,7 +56,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayDerecho() {
-            // Aquí va su código.
+            return derecho != null;
         }
 
         /**
@@ -64,8 +64,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el padre del vértice.
          * @throws NoSuchElementException si el vértice no tiene padre.
          */
-        @Override public VerticeArbolBinario<T> padre() {
-            // Aquí va su código.
+        @Override public VerticeArbolBinario<T> padre() throws NoSuchElementException{
+            if (padre == null) {
+              throw new NoSuchElementException("No hay padre");
+            }
+            return padre;
         }
 
         /**
@@ -73,8 +76,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el izquierdo del vértice.
          * @throws NoSuchElementException si el vértice no tiene izquierdo.
          */
-        @Override public VerticeArbolBinario<T> izquierdo() {
-            // Aquí va su código.
+        @Override public VerticeArbolBinario<T> izquierdo() throws NoSuchElementException{
+          if (izquierdo == null) {
+            throw new NoSuchElementException("No hay izquierdo");
+          }
+          return izquierdo;
         }
 
         /**
@@ -82,8 +88,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el derecho del vértice.
          * @throws NoSuchElementException si el vértice no tiene derecho.
          */
-        @Override public VerticeArbolBinario<T> derecho() {
-            // Aquí va su código.
+        @Override public VerticeArbolBinario<T> derecho() throws NoSuchElementException{
+          if (derecho == null) {
+            throw new NoSuchElementException("No hay derecho");
+          }
+          return derecho;
         }
 
         /**
@@ -91,7 +100,17 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            // Aquí va su código.
+            return altura(this);
+        }
+
+        private int altura(Vertice v){
+            if (v == null) {
+                return 0;
+            }
+            if (v.izquierdo == null && v.derecho == null) {
+                return 0;
+            }
+            return 1 + Math.max(altura(v.izquierdo), altura(v.derecho));
         }
 
         /**
@@ -99,15 +118,19 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la profundidad del vértice.
          */
         @Override public int profundidad() {
-            // Aquí va su código.
+            if (padre == null) {
+                return 0;
+            }
+            return 1 + padre.profundidad();
         }
 
+
         /**
          * Regresa el elemento al que apunta el vértice.
          * @return el elemento al que apunta el vértice.
          */
         @Override public T get() {
-            // Aquí va su código.
+            return elemento;
         }
 
         /**
@@ -124,7 +147,17 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             if (o == null || getClass() != o.getClass())
                 return false;
             @SuppressWarnings("unchecked") Vertice vertice = (Vertice)o;
-            // Aquí va su código.
+            return verticesIguales(this, vertice);
+        }
+
+        private boolean verticesIguales(Vertice vertice1, Vertice vertice2){
+          if (vertice1 == null && vertice2 == null) {
+                return true;
+            }
+            if ((vertice1 == null && vertice2 != null) || (vertice1 != null && vertice2 == null) || !vertice1.elemento.equals(vertice2.elemento)) {
+                return false;
+            }
+            return verticesIguales(vertice1.izquierdo, vertice2.izquierdo) && verticesIguales(vertice1.derecho, vertice2.derecho);
         }
 
         /**
@@ -132,7 +165,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return una representación en cadena del vértice.
          */
         public String toString() {
-            // Aquí va su código.
+            return elemento.toString();
         }
     }
 
@@ -153,12 +186,14 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *        binario.
      */
     public ArbolBinario(Coleccion<T> coleccion) {
-        // Aquí va su código.
+        for (T n: coleccion) {
+            agrega(n);
+        }
     }
 
     /**
      * Construye un nuevo vértice, usando una instancia de {@link Vertice}. Para
-     * crear vértices se debe utilizar este método en lugar del operador
+     * crear vértices se deb utilizar este método en lugar del operador
      * <code>new</code>, para que las clases herederas de ésta puedan
      * sobrecargarlo y permitir que cada estructura de árbol binario utilice
      * distintos tipos de vértices.
@@ -175,7 +210,14 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return la altura del árbol.
      */
     public int altura() {
-        // Aquí va su código.
+        return altura_00(raiz);
+    }
+
+     protected int altura_00(Vertice v) {
+        if (v == null) {
+            return -1;
+        }
+        return 1 + Math.max(altura_00(v.izquierdo), altura_00(v.derecho));
     }
 
     /**
@@ -183,7 +225,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return el número de elementos en el árbol.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return elementos;
     }
 
     /**
@@ -193,9 +235,20 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        return contiene_0(raiz, elemento);
     }
 
+    private boolean contiene_0(Vertice v, T elemento){
+        if (v == null) {
+            return false;
+        }else{
+            if (v.elemento.equals(elemento)) {
+                return true;
+            } else {
+                return contiene_0(v.izquierdo, elemento) || contiene_0(v.derecho, elemento);
+            }
+        }
+    }
     /**
      * Busca el vértice de un elemento en el árbol. Si no lo encuentra regresa
      * <tt>null</tt>.
@@ -204,7 +257,24 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <tt>null</tt> en otro caso.
      */
     public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return busca_0(raiz, elemento);
+    }
+
+    private Vertice busca_0(Vertice vertice, T elemento){
+        if (vertice == null) {
+            return null;
+        } else {
+            if (vertice.elemento.equals(elemento)) {
+                return vertice;
+            } else {
+                Vertice a = busca_0(vertice.izquierdo, elemento);
+                Vertice b = busca_0(vertice.derecho, elemento);
+                if (a != null) {
+                    return a;
+                }
+                return b;
+            }
+        }
     }
 
     /**
@@ -212,8 +282,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return el vértice que contiene la raíz del árbol.
      * @throws NoSuchElementException si el árbol es vacío.
      */
-    public VerticeArbolBinario<T> raiz() {
-        // Aquí va su código.
+    public VerticeArbolBinario<T> raiz()  throws NoSuchElementException{
+      if (raiz == null) {
+          throw new NoSuchElementException("Arbol vacio");
+      }
+      return raiz;
     }
 
     /**
@@ -222,14 +295,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return raiz == null;
     }
 
     /**
      * Limpia el árbol de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        raiz = null;
+        elementos = 0;
     }
 
     /**
@@ -243,7 +317,10 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             return false;
         @SuppressWarnings("unchecked")
             ArbolBinario<T> arbol = (ArbolBinario<T>)o;
-        // Aquí va su código.
+        if (esVacia()) {
+            return arbol.esVacia();
+        }
+        return raiz.equals(arbol.raiz);
     }
 
     /**
@@ -251,7 +328,51 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return una representación en cadena del árbol.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        if (raiz == null) {
+            return "";
+        }
+        boolean [] a = new boolean[altura() + 1];
+        for (int i = 0; i < altura() + 1; i++) {
+            a[i] = false;
+        }
+        return cadena(raiz, 0, a);
+    }
+
+    private String dibujaEspacios(int nivel, boolean [] a){
+        String s = "";
+        for (int i = 0; i < nivel; i++) {
+            if (a[i] == true) {
+                s += "│  ";
+            } else {
+                s += "   ";
+            }
+        }
+        return s;
+    }
+
+    private String cadena(Vertice v, int nivel, boolean [] a){
+        String s = v + "\n";
+        a[nivel] = true;
+        if (v.izquierdo != null && v.derecho != null) {
+            s += dibujaEspacios(nivel,a);
+            s += "├─›";
+            s += cadena(v.izquierdo, nivel + 1, a);
+            s += dibujaEspacios(nivel, a);
+            s += "└─»";
+            a[nivel] = false;
+            s += cadena(v.derecho, nivel + 1, a);
+        }else if (v.izquierdo != null) {
+            s += dibujaEspacios(nivel, a);
+            s += "└─›";
+            a[nivel] = false;
+            s += cadena(v.izquierdo, nivel + 1, a);
+        } else if (v.derecho != null) {
+            s += dibujaEspacios(nivel, a);
+            s += "└─»";
+            a[nivel] = false;
+            s += cadena(v.derecho, nivel + 1, a);
+        }
+        return s;
     }
 
     /**
diff --git a/src/mx/unam/ciencias/edd/ArbolBinarioCompleto.java b/src/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
index ff68b08..87b2620 100644
--- a/src/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
+++ b/src/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
@@ -18,17 +18,27 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
 
         /* Constructor que recibe la raíz del árbol. */
         public Iterador() {
-            // Aquí va su código.
+          cola = new Cola<>();
+          if (raiz != null){
+              cola.mete(raiz);
+          }
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !cola.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden BFS. */
         @Override public T next() {
-            // Aquí va su código.
+            Vertice v = cola.saca();
+            if (v.izquierdo != null) {
+                cola.mete(v.izquierdo);
+            }
+            if (v.derecho != null) {
+                cola.mete(v.derecho);
+            }
+            return v.elemento;
         }
     }
 
@@ -47,16 +57,43 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
     public ArbolBinarioCompleto(Coleccion<T> coleccion) {
         super(coleccion);
     }
-
     /**
+
      * Agrega un elemento al árbol binario completo. El nuevo elemento se coloca
      * a la derecha del último nivel, o a la izquierda de un nuevo nivel.
      * @param elemento el elemento a agregar al árbol.
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override public void agrega(T elemento) throws IllegalArgumentException{
+        if(elemento == null){
+	    throw new IllegalArgumentException();
+	    }
+	    Vertice v = nuevoVertice(elemento);
+	    if(raiz == null){
+          raiz = v;
+         elementos++;
+        return;
+        }
+        Cola<Vertice> c = new Cola<>();
+	    c.mete(raiz);
+       while(!c.esVacia()){
+          Vertice aux = c.saca();
+         if(aux.izquierdo == null){
+             aux.izquierdo = v;
+            aux.izquierdo.padre = aux;
+		    elementos++;
+		    return;
+         }
+         if(aux.derecho == null){
+	        aux.derecho = v;
+		    aux.derecho.padre = aux;
+		    elementos++;
+		    return;
+	      }
+	       c.mete(aux.izquierdo);
+	       c.mete(aux.derecho);
+        }
     }
 
     /**
@@ -66,7 +103,49 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if(elemento != null){
+	    Vertice v = (Vertice)busca(elemento);
+	    if(v != null){
+		      elementos--;
+		        if(elementos == 0){
+		            raiz = null;
+		            }else{
+		    Cola<Vertice> cola = new Cola<>();
+		    cola.mete(raiz);
+		    Vertice aux = null;
+		    while(!cola.esVacia()){
+			aux = cola.saca();
+			if(aux.izquierdo != null){
+			    cola.mete(aux.izquierdo);
+			}
+			if(aux.derecho != null){
+			    cola.mete(aux.derecho);
+			}
+		    }
+		    v.elemento = aux.elemento;
+		    aux.elemento = elemento;
+		    if(hijoIzquierdo(aux)){
+			aux.padre.izquierdo = null;
+		    }else{
+			aux.padre.derecho = null;
+		    }
+		}
+	    }
+	}
+    }
+
+    private boolean hijoIzquierdo(Vertice v){
+        if (!v.hayPadre()) {
+            return false;
+        }
+        return v.padre.izquierdo == v;
+    }
+
+    private boolean hijoDerecho(Vertice v){
+        if (!v.hayPadre()) {
+            return false;
+        }
+        return v.padre.derecho == v;
     }
 
     /**
@@ -75,16 +154,32 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @return la altura del árbol.
      */
     @Override public int altura() {
-        // Aquí va su código.
+      if (raiz == null)
+        return -1;
+      return (int) Math.floor(Math.log(this.getElementos())/Math.log(2));
     }
 
+
     /**
      * Realiza un recorrido BFS en el árbol, ejecutando la acción recibida en
      * cada elemento del árbol.
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void bfs(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+       if(!esVacia()){
+	    Cola<Vertice> cola = new Cola<>();
+	    cola.mete(raiz);
+	    while(!cola.esVacia()){
+		Vertice v = cola.saca();
+		accion.actua(v);
+		if(v.izquierdo != null){
+		    cola.mete(v.izquierdo);
+		}
+		if(v.derecho != null){
+		    cola.mete(v.derecho);
+		}
+	    }
+	}
     }
 
     /**
diff --git a/src/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java b/src/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
index c01db02..428cfbc 100644
--- a/src/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
+++ b/src/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
@@ -14,8 +14,7 @@ import java.util.Iterator;
  *       descendientes por la derecha.</li>
  * </ul>
  */
-public class ArbolBinarioOrdenado<T extends Comparable<T>>
-    extends ArbolBinario<T> {
+public class ArbolBinarioOrdenado<T extends Comparable<T>> extends ArbolBinario<T> {
 
     /* Clase privada para iteradores de árboles binarios ordenados. */
     private class Iterador implements Iterator<T> {
@@ -25,18 +24,33 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
 
         /* Construye un iterador con el vértice recibido. */
         public Iterador() {
-            // Aquí va su código.
+            pila = new Pila<>();
+            if (raiz == null) {
+                return;
+            }
+            Vertice v = raiz;
+            while(v != null){
+                pila.mete(v);
+                v = v.izquierdo;
+            }
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !pila.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden DFS in-order. */
         @Override public T next() {
-            // Aquí va su código.
-        }
+            Vertice v = pila.saca();
+            T elem = v.elemento;
+            v = v.derecho;
+	        while(v != null){
+                pila.mete(v);
+                v = v.izquierdo;
+	          }
+	           return elem;
+	          }
     }
 
     /**
@@ -68,10 +82,37 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * Agrega un nuevo elemento al árbol. El árbol conserva su orden in-order.
      * @param elemento el elemento a agregar.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override public void agrega(T elemento) throws IllegalArgumentException{
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        }
+		if(raiz == null){
+	    raiz = ultimoAgregado = nuevoVertice(elemento);
+        }else{
+           agrega(raiz, elemento);
+        }
+       elementos++;
+    }
+
+
+    private void agrega(Vertice vertice, T elemento) {
+          if (elemento.compareTo(vertice.elemento) <= 0)
+            if (!vertice.hayIzquierdo()) {
+                Vertice verticeNuevo = nuevoVertice(elemento);
+                verticeNuevo.padre = vertice;
+                vertice.izquierdo = ultimoAgregado = verticeNuevo;
+            } else
+                agrega(vertice.izquierdo, elemento);
+        else
+            if (!vertice.hayDerecho()) {
+                Vertice verticeNuevo = nuevoVertice(elemento);
+                verticeNuevo.padre = vertice;
+                vertice.derecho = ultimoAgregado = verticeNuevo;
+            } else
+		            agrega(vertice.derecho, elemento);
     }
 
+
     /**
      * Elimina un elemento. Si el elemento no está en el árbol, no hace nada; si
      * está varias veces, elimina el primero que encuentre (in-order). El árbol
@@ -79,7 +120,89 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        Vertice eliminar = busca(raiz, elemento), vi;
+        if (eliminar == null) {
+            return;
+        }
+        if (eliminar.hayIzquierdo()) {
+            vi = eliminar;
+            eliminar = maximoEnSubarbol(eliminar.izquierdo);
+            vi.elemento = eliminar.elemento;
+        }
+
+        if (!eliminar.hayIzquierdo() && !eliminar.hayDerecho()) {
+            eliminaHoja(eliminar);
+        } else if (!eliminar.hayIzquierdo()) {
+            eliminaSinHijoIzquierdo(eliminar);
+        } else {
+            eliminaSinHijoDerecho(eliminar);
+        }
+    }
+
+    /**
+     * Metodo para buscar el máximo de un subarbol
+     * @param v vertice actual
+     * @return Vertice - el vertice maximo del subarbol
+     */
+    protected Vertice maximoEnSubarbol(Vertice v){
+        if (v.derecho == null) {
+            return v;
+        }
+        return maximoEnSubarbol(v.derecho);
+    }
+
+    /**
+     * Auxiliar de elimina. Elimina una hoja.
+     * @param v el elemento a eliminar que debe ser hoja.
+     */
+    protected void eliminaHoja(Vertice v) {
+        if (raiz == v) {
+            raiz = null;
+            ultimoAgregado = null;
+        } else if (hijoIzquierdo(v)) {
+            v.padre.izquierdo = null;
+        } else {
+            v.padre.derecho = null;
+        }
+        elementos--;
+    }
+
+    /**
+     * Auxiliar de elimina. Elimina vertice que no tiene hijo izquierdo.
+     * @param v el elemento a eliminar que debe no tener hijo izquierdo.
+     */
+    protected void eliminaSinHijoIzquierdo(Vertice v) {
+        if (raiz == v) {
+            raiz = raiz.derecho;
+            v.derecho.padre = null;
+        } else {
+            v.derecho.padre = v.padre;
+            if (hijoIzquierdo(v)) {
+                v.padre.izquierdo = v.derecho;
+            } else {
+                v.padre.derecho = v.derecho;
+            }
+        }
+        elementos--;
+    }
+
+    /**
+     * Auxiliar de elimina. Elimina vertice que no tiene hijo derecho.
+     * @param v el elemento a eliminar que debe no tener hijo derecho.
+     */
+    protected void eliminaSinHijoDerecho(Vertice v) {
+        if (raiz == v) {
+            raiz = raiz.izquierdo;
+            v.izquierdo.padre = null;
+        } else {
+            v.izquierdo.padre = v.padre;
+            if (hijoIzquierdo(v)) {
+                v.padre.izquierdo = v.izquierdo;
+            } else {
+                v.padre.derecho = v.izquierdo;
+            }
+        }
+        elementos--;
     }
 
     /**
@@ -93,6 +216,7 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     protected Vertice intercambiaEliminable(Vertice vertice) {
         // Aquí va su código.
+        return null;
     }
 
     /**
@@ -113,7 +237,30 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         encuentra; <tt>null</tt> en otro caso.
      */
     @Override public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return busca(raiz, elemento);
+    }
+
+    /**
+     * Metodo para buscar un un elemento (auxiliar)
+     * @param vertice vertice del elemento
+     * @param elemento elemento a buscar
+     * @return Vertice - el vertice que posee al elemento
+     */
+    protected Vertice busca(Vertice vertice, T elemento){
+        if (vertice == null) {
+            return null;
+        } else {
+            if (vertice.elemento.equals(elemento)) {
+                return vertice;
+            } else {
+                Vertice a = busca(vertice.izquierdo, elemento);
+                Vertice b = busca(vertice.derecho, elemento);
+                if (a != null) {
+                    return a;
+                }
+                return b;
+            }
+        }
     }
 
     /**
@@ -132,12 +279,65 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
     }
 
     /**
+     * Metodo para verificar si el vertice es la raiz
+     * @param vertice vertice actual
+     * @return boolean - true si el la raiz, false en otro caso
+     */
+    private boolean esRaiz(Vertice vertice){
+        return vertice == raiz;
+    }
+
+    /**
      * Gira el árbol a la derecha sobre el vértice recibido. Si el vértice no
      * tiene hijo izquierdo, el método no hace nada.
      * @param vertice el vértice sobre el que vamos a girar.
      */
-    public void giraDerecha(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+    public void giraDerecha(VerticeArbolBinario<T> vertice){
+	        if (vertice == null || !vertice.hayIzquierdo()){
+            return;
+	}
+        Vertice v = (Vertice) vertice;
+        Vertice vIzq = v.izquierdo;
+        vIzq.padre = v.padre;
+        if(!esRaiz(v)){
+            if(hijoIzquierdo(v)){
+                v.padre.izquierdo = vIzq;
+            }else{
+                v.padre.derecho = vIzq;
+             }
+        }else{
+            raiz = vIzq;
+         }
+        v.izquierdo = vIzq.derecho;
+        if(vIzq.hayDerecho()){
+            vIzq.derecho.padre = v;
+         }
+        vIzq.derecho = v;
+        v.padre = vIzq;
+    }
+
+    /**
+     * Metodo para verificar si un vertice en hijo derecho
+     * @param v vertice actual
+     * @return boolean - true si v es hijo derecho, false en otro caso
+     */
+    protected boolean hijoDerecho(Vertice v){
+        if (!v.hayPadre()) {
+            return false;
+        }
+        return v.padre.derecho == v;
+    }
+
+    /**
+     * Metodo para verificar si un vertice es hijo hayIzquierdo
+     * @param v vertice actual
+     * @return boolean - true si v es hijo izquierdo, false en otro caso
+     */
+    protected boolean hijoIzquierdo(Vertice v){
+        if (!v.hayPadre()) {
+            return false;
+        }
+        return v.padre.izquierdo == v;
     }
 
     /**
@@ -146,7 +346,28 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraIzquierda(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        if (vertice == null || !vertice.hayDerecho()){
+            return;
+       }
+	   Vertice v = (Vertice) vertice;
+        Vertice vDer = v.derecho;
+        vDer.padre = v.padre;
+        if (!esRaiz(v)){
+            if (hijoIzquierdo(v)){
+                v.padre.izquierdo = vDer;
+           }else{
+                v.padre.derecho = vDer;
+           }
+        }else{
+            raiz = vDer;
+       }
+
+        v.derecho = vDer.izquierdo;
+        if (vDer.hayIzquierdo()){
+            vDer.izquierdo.padre = v;
+        }
+        vDer.izquierdo = v;
+        v.padre = vDer;
     }
 
     /**
@@ -155,7 +376,21 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPreOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPreOrder_0(raiz, accion);
+    }
+
+    /**
+     * Metodo auxliar pada dfsPreOrder.
+     * @param vertice vertice actual;
+     * @param accion la aciiona a realizar en cada elemento del árbol
+     */
+    private void dfsPreOrder_0(Vertice vertice, AccionVerticeArbolBinario<T> accion){
+        if (vertice == null) {
+            return;
+        }
+        accion.actua(vertice);
+        dfsPreOrder_0(vertice.izquierdo, accion);
+        dfsPreOrder_0(vertice.derecho, accion);
     }
 
     /**
@@ -164,7 +399,21 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsInOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsInOrder_0(raiz,accion);
+    }
+
+    /**
+     * Metodo auxliar pada dfsInOrder.
+     * @param vertice vertice actual
+     * @param accion la aciiona a realizar en cada elemento del árbol
+     */
+    private void dfsInOrder_0(Vertice vertice, AccionVerticeArbolBinario<T> accion){
+        if (vertice == null) {
+            return;
+        }
+        dfsInOrder_0(vertice.izquierdo, accion);
+        accion.actua(vertice);
+        dfsInOrder_0(vertice.derecho, accion);
     }
 
     /**
@@ -173,7 +422,21 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPostOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPostOrder_0(raiz, accion);
+    }
+
+    /**
+     * Metodo auxliar pada dfsPostOrder.
+     * @param vertice vertice actual
+     * @param accion la aciiona a realizar en cada elemento del árbol
+     */
+    private void dfsPostOrder_0(Vertice vertice, AccionVerticeArbolBinario<T> accion){
+        if(vertice == null){
+            return;
+        }
+        dfsPostOrder_0(vertice.izquierdo, accion);
+        dfsPostOrder_0(vertice.derecho, accion);
+        accion.actua(vertice);
     }
 
     /**
diff --git a/src/mx/unam/ciencias/edd/ArbolRojinegro.java b/src/mx/unam/ciencias/edd/ArbolRojinegro.java
index 7290ddb..a6b6da9 100644
--- a/src/mx/unam/ciencias/edd/ArbolRojinegro.java
+++ b/src/mx/unam/ciencias/edd/ArbolRojinegro.java
@@ -15,8 +15,7 @@ package mx.unam.ciencias.edd;
  *
  * Los árboles rojinegros se autobalancean.
  */
-public class ArbolRojinegro<T extends Comparable<T>>
-    extends ArbolBinarioOrdenado<T> {
+public class ArbolRojinegro<T extends Comparable<T>> extends ArbolBinarioOrdenado<T> {
 
     /**
      * Clase interna protegida para vértices de árboles rojinegros. La única
@@ -25,7 +24,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     protected class VerticeRojinegro extends Vertice {
 
-        /** El color del vértice. */
+        /* El color del vértice. */
         public Color color;
 
         /**
@@ -33,7 +32,8 @@ public class ArbolRojinegro<T extends Comparable<T>>
          * @param elemento el elemento del vértice.
          */
         public VerticeRojinegro(T elemento) {
-            // Aquí va su código.
+            super(elemento);
+            color = Color.NINGUNO;
         }
 
         /**
@@ -41,7 +41,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
          * @return una representación en cadena del vértice rojinegro.
          */
         public String toString() {
-            // Aquí va su código.
+          return (color == Color.ROJO) ? "R{" + elemento.toString() + "}" : "N{" + elemento.toString() + "}";
         }
 
         /**
@@ -59,7 +59,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
                 return false;
             @SuppressWarnings("unchecked")
                 VerticeRojinegro vertice = (VerticeRojinegro)o;
-            // Aquí va su código.
+            return (color == vertice.color && super.equals(o));
         }
     }
 
@@ -68,7 +68,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
      * de {@link ArbolBinarioOrdenado}.
      */
     public ArbolRojinegro() {
-        // Aquí va su código.
+        super();
     }
 
     /**
@@ -78,7 +78,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
      *        rojinegro.
      */
     public ArbolRojinegro(Coleccion<T> coleccion) {
-        // Aquí va su código.
+        super(coleccion);
     }
 
     /**
@@ -88,7 +88,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
      * @return un nuevo vértice rojinegro con el elemento recibido dentro del mismo.
      */
     @Override protected Vertice nuevoVertice(T elemento) {
-        // Aquí va su código.
+        return new VerticeRojinegro(elemento);
     }
 
     /**
@@ -99,7 +99,24 @@ public class ArbolRojinegro<T extends Comparable<T>>
      *         VerticeRojinegro}.
      */
     public Color getColor(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+	     if (vertice == null) {
+             return Color.NEGRO;
+         }
+         if (!(vertice instanceof ArbolRojinegro.VerticeRojinegro)) {
+             throw new ClassCastException("No es instancia de la clase");
+         }
+         VerticeRojinegro v = verticeRojinegro(vertice);
+         return v.color;
+    }
+
+    /**
+     * Metodo para hacer un casting de VerticeArbolBinario a VerticeRojinegro
+     * @param vertice vertice a castear
+     * @return VerticeRojinegro - vertice ya casteado
+     */
+    private VerticeRojinegro verticeRojinegro(VerticeArbolBinario<T> vertice){
+        VerticeRojinegro v = (VerticeRojinegro)vertice;
+        return v;
     }
 
     /**
@@ -109,20 +126,275 @@ public class ArbolRojinegro<T extends Comparable<T>>
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        super.agrega(elemento);
+        VerticeRojinegro vertice = verticeRojinegro(ultimoAgregado);
+        vertice.color = Color.ROJO;
+        auxAgrega(vertice);
+    }
+
+    /**
+     * Metodo auxiliar de agrega. Rebalancea el ArbolRojinegro
+     * @param vertice vertice actual
+     */
+    private void auxAgrega(VerticeRojinegro vertice){
+       VerticeRojinegro verticePapa;
+       VerticeRojinegro verticeAbuelo;
+       VerticeRojinegro verticeTio;
+       VerticeRojinegro verticeAux;
+        /*Caso 1*/
+        if(!vertice.hayPadre()){
+	         vertice.color = Color.NEGRO;
+           return;
+        }
+        verticePapa = verticeRojinegro(vertice.padre);
+
+        /*Caso 2*/
+        if (esNegro(verticePapa))
+            return;
+
+        verticeAbuelo = verticeRojinegro(verticePapa.padre);
+
+        /*Caso 3*/
+       if (hijoIzquierdo(verticePapa))
+	      verticeTio = verticeRojinegro(verticeAbuelo.derecho);
+       else
+	      verticeTio = verticeRojinegro(verticeAbuelo.izquierdo);
+
+         if (esRojo(verticeTio)) {
+             verticeTio.color = verticePapa.color = Color.NEGRO;
+             verticeAbuelo.color = Color.ROJO;
+             auxAgrega(verticeAbuelo);
+             return;
+        }
+
+        /*Caso 4*/
+        if (cruzados(vertice, verticePapa)) {
+           if (hijoIzquierdo(verticePapa)) {
+	             super.giraIzquierda(verticePapa);
+            }else {
+	              super.giraDerecha(verticePapa);
+            }
+           verticeAux = verticePapa;
+           verticePapa = vertice;
+           vertice = verticeAux;
+        }
+
+        /*Caso 5*/
+        verticePapa.color = Color.NEGRO;
+        verticeAbuelo.color = Color.ROJO;
+        if (hijoIzquierdo(vertice)) {
+           super.giraDerecha(verticeAbuelo);
+        } else {
+           super.giraIzquierda(verticeAbuelo);
+        }
     }
 
+
+    /**
+     * Metodo para verificar si dos vertice tienen el mismo padre
+     * @param vertice1 vertice
+     * @param vertice2 vertice
+     * @return boolean - true si el padre de vertice1 y vertice2 es el mismo, false en otro caso
+     */
+    private boolean cruzados(VerticeRojinegro vertice1, VerticeRojinegro vertice2){
+        if(vertice1.padre.izquierdo == vertice1 && vertice2.padre.derecho == vertice2)
+            return true;
+        if(vertice1.padre.derecho == vertice1 && vertice2.padre.izquierdo == vertice2)
+            return true;
+        return false;
+  }
+
     /**
      * Elimina un elemento del árbol. El método elimina el vértice que contiene
      * el elemento, y recolorea y gira el árbol como sea necesario para
      * rebalancearlo.
      * @param elemento el elemento a eliminar del árbol.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override public void elimina(T elemento)  {
+        VerticeRojinegro v = verticeRojinegro(busca(raiz, elemento));
+        VerticeRojinegro fantasma = null;
+        VerticeRojinegro hijo;
+        if(v == null){
+            return;
+        }
+        if (v.hayIzquierdo()) {
+          VerticeRojinegro aux = v;
+          v = verticeRojinegro(maximoEnSubarbol(v.izquierdo));
+          aux.elemento = v.elemento;
+        }
+
+        if (!v.hayIzquierdo() && !v.hayDerecho()) {
+            fantasma = verticeRojinegro(nuevoVertice(null));
+            fantasma.color = Color.NEGRO;
+            fantasma.padre = v;
+            v.izquierdo = fantasma;
+        }
+
+        if(v.hayIzquierdo()){
+        hijo = verticeRojinegro(v.izquierdo);
+        } else{
+            hijo = verticeRojinegro(v.derecho);
+        }
+        subirHijo(v);
+
+        if (esNegro(v) && esNegro(hijo)) {
+            auxElimina(hijo);
+        } else {
+            hijo.color = Color.NEGRO;
+        }
+
+        if (fantasma != null) {
+            if (fantasma == raiz) {
+                raiz = ultimoAgregado = fantasma = null;
+            } else {
+                if (hijoIzquierdo(fantasma)) {
+                    fantasma.padre.izquierdo = null;
+                } else {
+                    fantasma.padre.derecho = null;
+                }
+            }
+        }
+        elementos--;
+    }
+
+    private void subirHijo(VerticeRojinegro v){
+        if (v.hayIzquierdo()) {
+            if (v == raiz) {
+              raiz = v.izquierdo;
+              raiz.padre = null;
+            } else {
+                v.izquierdo.padre = v.padre;
+                if (hijoIzquierdo(v)) {
+                    v.padre.izquierdo = v.izquierdo;
+                } else {
+                    v.padre.derecho = v.izquierdo;
+                }
+            }
+        } else {
+            if (v == raiz) {
+                raiz = v.derecho;
+                raiz.padre = null;
+            } else {
+                v.derecho.padre = v.padre;
+                if (hijoIzquierdo(v)) {
+                    v.padre.izquierdo = v.derecho;
+                } else {
+                    v.padre.derecho = v.derecho;
+                }
+            }
+        }
+
+    }
+
+    /**
+     * Metodo auxliar para eliminar. Rebalancea el ArbolRojinegro.
+     * @param vertice vertice actual
+     */
+    private void auxElimina(VerticeRojinegro vertice){
+      VerticeRojinegro verticeAbuelo;
+      VerticeRojinegro verticePapa;
+      VerticeRojinegro verticeHermano;
+      VerticeRojinegro verticeSobrinoIzq;
+      VerticeRojinegro verticeSobrinoDer;
+
+      /*Caso 1*/
+      if (!vertice.hayPadre()) {
+          raiz = vertice;
+          vertice.color = Color.NEGRO;
+          return;
+      }
+      verticePapa = verticeRojinegro(vertice.padre);
+      verticeHermano = (hijoIzquierdo(vertice)) ? (VerticeRojinegro) vertice.padre.derecho : (VerticeRojinegro) vertice.padre.izquierdo;
+       /*Caso 2*/
+       if (esNegro(verticePapa) && esRojo(verticeHermano)) {
+           verticePapa.color = Color.ROJO;
+           verticeHermano.color = Color.NEGRO;
+           if (hijoIzquierdo(vertice)) {
+               super.giraIzquierda(verticePapa);
+           } else {
+               super.giraDerecha(verticePapa);
+           }
+           verticePapa = verticeRojinegro(vertice.padre);
+           verticeHermano = (hijoIzquierdo(vertice)) ? (VerticeRojinegro) vertice.padre.derecho : (VerticeRojinegro) vertice.padre.izquierdo;
+       }
+       verticeSobrinoIzq = verticeRojinegro(verticeHermano.izquierdo);
+       verticeSobrinoDer = verticeRojinegro(verticeHermano.derecho);
+       /*Caso 3*/
+       if (esNegro(verticePapa) && esNegro(verticeHermano) && esNegro(verticeSobrinoIzq) && esNegro(verticeSobrinoDer)) {
+           verticeHermano.color = Color.ROJO;
+           auxElimina(verticePapa);
+           return;
+       }
+
+       /*Caso 4*/
+       //if (esRojo(verticePapa) && esNegro(verticeHermano) && esNegro(verticeSobrinoIzq) && esNegro(verticeSobrinoDer)) {
+       if(verticePapa.color != Color.NEGRO && verticeHermano.color == Color.NEGRO && (verticeSobrinoIzq == null || verticeSobrinoIzq.color == Color.NEGRO) && (verticeSobrinoDer == null || verticeSobrinoDer.color == Color.NEGRO)){
+           verticePapa.color = Color.NEGRO;
+           verticeHermano.color = Color.ROJO;
+           return;
+        }
+
+       /*Caso 5*/
+       if (sobrinosBicolor(verticeSobrinoIzq, verticeSobrinoDer) && sonCruzados(vertice, verticeSobrinoIzq, verticeSobrinoDer)) {
+
+           if (esRojo(verticeSobrinoIzq)) {
+               verticeSobrinoIzq.color = Color.NEGRO;
+           } else {
+               verticeSobrinoDer.color = Color.NEGRO;
+           }
+           verticeHermano.color = Color.ROJO;
+
+           if (hijoIzquierdo(vertice)) {
+               super.giraDerecha(verticeHermano);
+           } else {
+               super.giraIzquierda(verticeHermano);
+           }
+           verticeHermano = (hijoIzquierdo(vertice)) ? (VerticeRojinegro) vertice.padre.derecho : (VerticeRojinegro) vertice.padre.izquierdo;
+           verticeSobrinoIzq = verticeRojinegro(verticeHermano.izquierdo);
+           verticeSobrinoDer = verticeRojinegro(verticeHermano.derecho);
+        }
+
+        /*Caso 6*/
+        verticeHermano.color = verticePapa.color;
+        verticePapa.color = Color.NEGRO;
+        if (hijoIzquierdo(vertice)) {
+            verticeSobrinoDer.color = Color.NEGRO;
+        } else {
+            verticeSobrinoIzq.color = Color.NEGRO;
+        }
+
+        if (hijoIzquierdo(vertice)) {
+            super.giraIzquierda(verticePapa);
+        } else {
+            super.giraDerecha(verticePapa);
+        }
+    }
+
+    /**
+     * Metodo para verificar si los sobrinos son cruzados
+     * @param vertice vertice actual
+     * @param sobrinoIzq sobrino izquierdo
+     * @param sobrinoDer sobrino derecho
+     * @return boolean - true si vertice es hijo derecho y sobrinoIzq es NEGRO y sobrinoDer es ROJO ó
+     *                   vertice es hijo izquierdo y sobrinoIzq es ROJO y sobrinoDer es NEGRO,
+     *                   false en otro caso
+     */
+    private boolean sonCruzados(VerticeRojinegro vertice, VerticeRojinegro sobrinoIzq, VerticeRojinegro sobrinoDer){
+        return hijoDerecho(vertice) && esNegro(sobrinoIzq) && esRojo(sobrinoDer) || hijoIzquierdo(vertice) && esRojo(sobrinoIzq) && esNegro(sobrinoDer);
     }
 
     /**
+     * Metodo para verificar si los vertices sobrinos son sobrinosBicolor
+     * @param si sobrino izquierdo
+     * @param sd sobrino derecho
+     * @return boolean - true si si es ROJO y sd es NEGRO ó si es NEGRO y sd es ROJO, false en otro caso
+     */
+    private boolean sobrinosBicolor(VerticeRojinegro si, VerticeRojinegro sd){
+        return esNegro (si) && esRojo(sd) || esRojo(si) && esNegro(sd);
+    }
+
+
+    /**
      * Lanza la excepción {@link UnsupportedOperationException}: los árboles
      * rojinegros no pueden ser girados a la izquierda por los usuarios de la
      * clase, porque se desbalancean.
@@ -147,4 +419,22 @@ public class ArbolRojinegro<T extends Comparable<T>>
                                                 "pueden girar a la derecha " +
                                                 "por el usuario.");
     }
+
+    /**
+     * Metodo para verificar si un vertice es ROJO
+     * @param vertice vertice actual
+     * @return booolean - true si es ROJO, false en otro caso
+     */
+    private boolean esRojo(VerticeRojinegro vertice){
+        return vertice != null && vertice.color == Color.ROJO;
+    }
+
+    /**
+     * Metodo para verificar si un vertice es NEGRO
+     * @param vertice vertice actual
+     * @return boolean - true si el NEGRO, false en otro caso
+     */
+    private boolean esNegro(VerticeRojinegro vertice){
+        return vertice == null || vertice.color == Color.NEGRO;
+    }
 }
diff --git a/src/mx/unam/ciencias/edd/Arreglos.java b/src/mx/unam/ciencias/edd/Arreglos.java
index 641317c..508932f 100644
--- a/src/mx/unam/ciencias/edd/Arreglos.java
+++ b/src/mx/unam/ciencias/edd/Arreglos.java
@@ -11,23 +11,55 @@ public class Arreglos {
     private Arreglos() {}
 
     /**
-     * Ordena el arreglo recibido usando QickSort.
+     * Ordena el arreglo recibido usando QuickSort.
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo el arreglo a ordenar.
      * @param comparador el comparador para ordenar el arreglo.
      */
-    public static <T> void
-    quickSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> void quickSort(T [] arreglo, Comparator<T> comparador) {
+      quickSort_0(arreglo, comparador, 0 , arreglo.length - 1);
     }
 
     /**
-     * Ordena el arreglo recibido usando QickSort.
+     * Metodo auxiliar para quickSort
+     * @param <T> tipo del que puede ser el arreglos
+     * @param arreglo el arreglo a ordenar
+     * @param comparador el comparador para ordenar el arreglo
+     * @param izq primer indice del arreglo
+     * @param der ultimo indice del arreglo
+     */
+    private static <T> void quickSort_0(T [] arreglo, Comparator<T> comparador, int izq, int der){
+      int pivote;
+      if (izq >= der) {
+        return;
+      }
+      int i = izq;
+      int j = der;
+      if (izq != der) {
+        pivote = izq;
+        while (izq != der) {
+          while (comparador.compare(arreglo[der], arreglo[izq]) >= 0 && izq < der)
+            der--;
+            while(comparador.compare(arreglo[izq], arreglo[der]) < 0 && izq < der)
+              izq++;
+
+          if (der != izq) {
+            swap(arreglo, der, izq);
+          }
+          if (izq == der) {
+            quickSort_0(arreglo, comparador, i, izq - 1);
+            quickSort_0(arreglo, comparador, izq + 1, j);
+          }
+        }
+       }
+    }
+
+    /**
+     * Ordena el arreglo recibido usando QuickSort.
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo un arreglo cuyos elementos son comparables.
      */
-    public static <T extends Comparable<T>> void
-    quickSort(T[] arreglo) {
+    public static <T extends Comparable<T>> void quickSort(T [] arreglo) {
         quickSort(arreglo, (a, b) -> a.compareTo(b));
     }
 
@@ -37,9 +69,17 @@ public class Arreglos {
      * @param arreglo el arreglo a ordenar.
      * @param comparador el comparador para ordernar el arreglo.
      */
-    public static <T> void
-    selectionSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> void selectionSort(T [] arreglo, Comparator<T> comparador) {
+        int menor;
+        for (int i = 0; i < arreglo.length - 1; i++) {
+            menor = i;
+            for (int j = i + 1; j < arreglo.length; j++) {
+                if (comparador.compare(arreglo[j],arreglo[menor]) < 0) {
+                    swap(arreglo, menor, j);
+                }
+            }
+            swap(arreglo, i , menor);
+        }
     }
 
     /**
@@ -47,8 +87,7 @@ public class Arreglos {
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo un arreglo cuyos elementos son comparables.
      */
-    public static <T extends Comparable<T>> void
-    selectionSort(T[] arreglo) {
+    public static <T extends Comparable<T>> void selectionSort(T [] arreglo) {
         selectionSort(arreglo, (a, b) -> a.compareTo(b));
     }
 
@@ -61,12 +100,35 @@ public class Arreglos {
      * @param comparador el comparador para hacer la búsqueda.
      * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
      */
-    public static <T> int
-    busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> int busquedaBinaria(T [] arreglo, T elemento, Comparator<T> comparador) {
+        return busquedaBinaria_0(arreglo, elemento, comparador, 0, arreglo.length - 1);
     }
 
     /**
+     * Metodo auxiliar para busquedaBinaria.
+     * @param <T> tipo del que puede ser el arreglo.
+     * @param arreglo el arreglo dónde buscar.
+     * @param elemento el elemento a buscar.
+     * @param comparador el comparador para hacer la búsqueda.
+     * @param izq subarreglo izquierdo del arreglo original.
+     * @param der subarreglo derecho del arreglo original.
+     * @return el índice del elemento del arreglo, o -1 si no se encuentra.
+     */
+     private static <T> int busquedaBinaria_0(T [] arreglo, T elemento, Comparator<T> comparador, int izq, int der){
+         int mitad = (izq + der)/2;
+         if (izq > der) {
+             return - 1;
+         }
+         if (comparador.compare(arreglo[mitad], elemento) < 0) {
+             return busquedaBinaria_0(arreglo, elemento, comparador, mitad + 1, der);
+         } else if (comparador.compare(arreglo[mitad], elemento) > 0){
+             return busquedaBinaria_0(arreglo, elemento, comparador, izq, mitad - 1);
+         } else {
+             return mitad;
+         }
+     }
+
+    /**
      * Hace una búsqueda binaria del elemento en el arreglo. Regresa el índice
      * del elemento en el arreglo, o -1 si no se encuentra.
      * @param <T> tipo del que puede ser el arreglo.
@@ -74,8 +136,21 @@ public class Arreglos {
      * @param elemento el elemento a buscar.
      * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
      */
-    public static <T extends Comparable<T>> int
-    busquedaBinaria(T[] arreglo, T elemento) {
+    public static <T extends Comparable<T>> int busquedaBinaria(T [] arreglo, T elemento) {
         return busquedaBinaria(arreglo, elemento, (a, b) -> a.compareTo(b));
     }
+
+    /**
+     * Metodo auxiliar para intercambiar valores
+     * @param <T> tipo del que puede ser el arreglo
+     * @param arreglo arreglo del que se intercambian valores
+     * @param i valor a intercambiar a la posicion j
+     * @param j valor a intercambiar a la posicion i
+     */
+    private static <T> void swap(T [] arreglo, int i, int j){
+		T temp = arreglo[i];
+		arreglo[i] = arreglo[j];
+		arreglo[j] = temp;
+    }
+
 }
diff --git a/src/mx/unam/ciencias/edd/Cola.java b/src/mx/unam/ciencias/edd/Cola.java
index 8ab59f9..64445aa 100644
--- a/src/mx/unam/ciencias/edd/Cola.java
+++ b/src/mx/unam/ciencias/edd/Cola.java
@@ -10,7 +10,13 @@ public class Cola<T> extends MeteSaca<T> {
      * @return una representación en cadena de la cola.
      */
     @Override public String toString() {
-        // Aquí va su código.
+      Nodo nodo = cabeza;
+          String r = "";
+          while (nodo != null) {
+            r += nodo.elemento + ",";
+            nodo = nodo.siguiente;
+          }
+          return r;
     }
 
     /**
@@ -19,7 +25,16 @@ public class Cola<T> extends MeteSaca<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    @Override public void mete(T elemento) {
-        // Aquí va su código.
+    @Override public void mete(T elemento) throws IllegalArgumentException{
+        if (elemento == null) {
+            throw new IllegalArgumentException("Elemento nulo");
+        }
+        Nodo nodo = new Nodo(elemento);
+        if(rabo == null){
+            cabeza = rabo = nodo;
+        } else {
+            rabo.siguiente = nodo;
+            rabo = nodo;
+        }
     }
 }
diff --git a/src/mx/unam/ciencias/edd/Conjunto.java b/src/mx/unam/ciencias/edd/Conjunto.java
index 0795c48..b3853f6 100644
--- a/src/mx/unam/ciencias/edd/Conjunto.java
+++ b/src/mx/unam/ciencias/edd/Conjunto.java
@@ -14,7 +14,7 @@ public class Conjunto<T> implements Coleccion<T> {
      * Crea un nuevo conjunto.
      */
     public Conjunto() {
-        // Aquí va su código.
+        conjunto = new Diccionario<T, T>();
     }
 
     /**
@@ -22,7 +22,7 @@ public class Conjunto<T> implements Coleccion<T> {
      * @param n el número tentativo de elementos.
      */
     public Conjunto(int n) {
-        // Aquí va su código.
+      conjunto = new Diccionario<T, T>(n);
     }
 
     /**
@@ -31,7 +31,10 @@ public class Conjunto<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si el elemento es <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+      if (elemento == null) {
+        throw new IllegalArgumentException();
+      }
+      conjunto.agrega(elemento, elemento);
     }
 
     /**
@@ -41,15 +44,17 @@ public class Conjunto<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+      return conjunto.contiene(elemento);
     }
 
     /**
      * Elimina el elemento del conjunto, si está.
      * @param elemento el elemento que queremos eliminar del conjunto.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override public void elimina(T elemento){
+      if (elemento != null) {
+        conjunto.elimina(elemento);
+      }
     }
 
     /**
@@ -58,7 +63,7 @@ public class Conjunto<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+      return conjunto.esVacia();
     }
 
     /**
@@ -66,14 +71,14 @@ public class Conjunto<T> implements Coleccion<T> {
      * @return el número de elementos en el conjunto.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+      return conjunto.getElementos();
     }
 
     /**
      * Limpia el conjunto de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+      conjunto.limpia();
     }
 
     /**
@@ -82,7 +87,13 @@ public class Conjunto<T> implements Coleccion<T> {
      * @return la intersección del conjunto y el conjunto recibido.
      */
     public Conjunto<T> interseccion(Conjunto<T> conjunto) {
-        // Aquí va su código.
+      Conjunto<T> c = new Conjunto<>();
+      for (T a : this.conjunto) {
+        if (conjunto.contiene(a)) {
+          c.agrega(a);
+        }
+      }
+      return c;
     }
 
     /**
@@ -91,7 +102,14 @@ public class Conjunto<T> implements Coleccion<T> {
      * @return la unión del conjunto y el conjunto recibido.
      */
     public Conjunto<T> union(Conjunto<T> conjunto) {
-        // Aquí va su código.
+      Conjunto<T> c = new Conjunto<>();
+      for (T a : this.conjunto) {
+        c.agrega(a);
+      }
+      for (T a : conjunto) {
+        c.agrega(a);
+      }
+      return c;
     }
 
     /**
@@ -99,7 +117,17 @@ public class Conjunto<T> implements Coleccion<T> {
      * @return una representación en cadena del conjunto.
      */
     @Override public String toString() {
-        // Aquí va su código.
+      int i = getElementos();
+      String s = "{ ";
+      for (T e : conjunto) {
+        s += e;
+        if (i - 1 != 0) {
+          s += ", ";
+        }
+        i--;
+      }
+      s += " }";
+      return s;
     }
 
     /**
@@ -112,7 +140,7 @@ public class Conjunto<T> implements Coleccion<T> {
         if (o == null || getClass() != o.getClass())
             return false;
         @SuppressWarnings("unchecked") Conjunto<T> c = (Conjunto<T>)o;
-        // Aquí va su código.
+        return c.conjunto.equals(conjunto);
     }
 
     /**
@@ -120,6 +148,6 @@ public class Conjunto<T> implements Coleccion<T> {
      * @return un iterador para iterar el conjunto.
      */
     @Override public Iterator<T> iterator() {
-        // Aquí va su código.
+      return conjunto.iterator();
     }
 }
diff --git a/src/mx/unam/ciencias/edd/Diccionario.java b/src/mx/unam/ciencias/edd/Diccionario.java
index e3970d8..8045d19 100644
--- a/src/mx/unam/ciencias/edd/Diccionario.java
+++ b/src/mx/unam/ciencias/edd/Diccionario.java
@@ -21,7 +21,8 @@ public class Diccionario<K, V> implements Iterable<V> {
 
         /* Construye una nueva entrada. */
         public Entrada(K llave, V valor) {
-            // Aquí va su código.
+    	    this.llave = llave;
+    	    this.valor = valor;
         }
     }
 
@@ -36,17 +37,25 @@ public class Diccionario<K, V> implements Iterable<V> {
         /* Construye un nuevo iterador, auxiliándose de las listas del
          * diccionario. */
         public Iterador() {
-            // Aquí va su código.
+          Lista<Entrada> lista = new Lista<>();
+          for (int i = 0; i < entradas.length; i++) {
+           if (entradas[i] !=  null) {
+             for (Entrada e : entradas[i]) {
+	              lista.agrega(e);
+              }
+            }
+         }
+         iterador = lista.iterator();
         }
 
         /* Nos dice si hay una siguiente entrada. */
         public boolean hasNext() {
-            // Aquí va su código.
+          return iterador.hasNext();
         }
 
         /* Regresa la siguiente entrada. */
         public Entrada siguiente() {
-            // Aquí va su código.
+          return iterador.next();
         }
     }
 
@@ -56,12 +65,12 @@ public class Diccionario<K, V> implements Iterable<V> {
 
         /* Construye un nuevo iterador de llaves del diccionario. */
         public IteradorLlaves() {
-            // Aquí va su código.
+          super();
         }
 
         /* Regresa el siguiente elemento. */
         @Override public K next() {
-            // Aquí va su código.
+          return super.siguiente().llave;
         }
     }
 
@@ -71,12 +80,12 @@ public class Diccionario<K, V> implements Iterable<V> {
 
         /* Construye un nuevo iterador de llaves del diccionario. */
         public IteradorValores() {
-            // Aquí va su código.
+          super();
         }
 
         /* Regresa el siguiente elemento. */
         @Override public V next() {
-            // Aquí va su código.
+          return super.siguiente().valor;
         }
     }
 
@@ -106,7 +115,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      * predeterminados.
      */
     public Diccionario() {
-        // Aquí va su código.
+      this(MINIMA_CAPACIDAD, (K llave) -> llave.hashCode());
     }
 
     /**
@@ -115,7 +124,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @param capacidad la capacidad a utilizar.
      */
     public Diccionario(int capacidad) {
-        // Aquí va su código.
+      this(capacidad, (K llave) -> llave.hashCode());
     }
 
     /**
@@ -124,7 +133,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @param dispersor el dispersor a utilizar.
      */
     public Diccionario(Dispersor<K> dispersor) {
-        // Aquí va su código.
+      this(MINIMA_CAPACIDAD, dispersor);
     }
 
     /**
@@ -134,7 +143,14 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @param dispersor el dispersor a utilizar.
      */
     public Diccionario(int capacidad, Dispersor<K> dispersor) {
-        // Aquí va su código.
+    	this.dispersor = dispersor;
+    	if (capacidad < MINIMA_CAPACIDAD) {
+    	    entradas = nuevoArreglo(MINIMA_CAPACIDAD);
+    	} else {
+    	    capacidad = tamanio(capacidad);
+    	    entradas = nuevoArreglo(capacidad);
+    	}
+    	elementos = 0;
     }
 
     /**
@@ -146,7 +162,55 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @throws IllegalArgumentException si la llave o el valor son nulos.
      */
     public void agrega(K llave, V valor) {
-        // Aquí va su código.
+    	if (llave == null || valor == null) {
+    	    throw new IllegalArgumentException();
+    	}
+    	int i = (entradas.length - 1) & (dispersor.dispersa(llave));
+    	if (entradas[i] == null) {
+    	    entradas[i] = new Lista<Entrada>();
+    	}
+    	for (Entrada e : entradas[i]) {
+    	    if (e.llave.equals(llave)) {
+    		      e.valor = valor;
+    		        return;
+    	    }
+    	}
+    	entradas[i].agrega(new Entrada(llave, valor));
+    	elementos++;
+    	if (carga() > MAXIMA_CARGA) {
+    	    hazCrecerArreglista();
+    	}
+
+    }
+
+    /**
+     * Metodo para aumentar el tamaño del arreglo
+     */
+     private void hazCrecerArreglista(){
+    	int m = tamanio(entradas.length);
+    	elementos = 0;
+    	Lista<Entrada>[] arreglistaViejo = entradas;
+    	Lista<Entrada>[] arreglistaNuevo = nuevoArreglo(m);
+    	entradas = arreglistaNuevo;
+    	   for (int i = 0; i < arreglistaViejo.length; i++) {
+    	      if (arreglistaViejo[i] != null) {
+    		        for (Entrada ent : arreglistaViejo[i]) {
+    		            agrega(ent.llave, ent.valor);
+		            }
+             }
+        }
+    }
+
+    /**
+     * Metodo para obtener el tamanio del nuevoArreglo
+     * @param n la capacidad del arreglo actual
+     * @return int la capacidad del arreglo
+     */private int tamanio(int n){
+      n = (n < 64) ? 64 : n;
+      int c = 1;
+      while (c < n * 2)
+          c *= 2;
+      return c;
     }
 
     /**
@@ -157,7 +221,20 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @throws NoSuchElementException si la llave no está en el diccionario.
      */
     public V get(K llave) {
-        // Aquí va su código.
+      V valor = null;
+      if (llave == null) {
+        throw new IllegalArgumentException("Llave nula");
+      }
+      if (!contiene(llave)) {
+        throw new NoSuchElementException("La llave no esta en el diccionario");
+      }
+      int i = (entradas.length - 1) & (dispersor.dispersa(llave));
+      for (Entrada ent : entradas[i]) {
+        if (ent.llave.equals(llave)) {
+          valor = ent.valor;
+        }
+      }
+      return valor;
     }
 
     /**
@@ -167,7 +244,19 @@ public class Diccionario<K, V> implements Iterable<V> {
      *         <tt>false</tt> en otro caso.
      */
     public boolean contiene(K llave) {
-        // Aquí va su código.
+      if (llave == null) {
+        return false;
+      }
+      int i = (entradas.length - 1) & (dispersor.dispersa(llave));
+      if (entradas[i] == null) {
+        return false;
+      }
+      for (Entrada e : entradas[i]) {
+        if (e.llave.equals(llave)) {
+          return true;
+        }
+      }
+      return false;
     }
 
     /**
@@ -178,7 +267,19 @@ public class Diccionario<K, V> implements Iterable<V> {
      *         el diccionario.
      */
     public void elimina(K llave) {
-        // Aquí va su código.
+      if (llave == null) {
+        throw new IllegalArgumentException();
+      }
+      if (!contiene(llave)) {
+        throw new NoSuchElementException();
+      }
+      int i = (entradas.length - 1) & (dispersor.dispersa(llave));
+      for (Entrada e : entradas[i]) {
+        if (e.llave.equals(llave)) {
+          entradas[i].elimina(e);
+        }
+      }
+      elementos--;
     }
 
     /**
@@ -186,7 +287,13 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @return cuántas colisiones hay en el diccionario.
      */
     public int colisiones() {
-        // Aquí va su código.
+      int col = 0;
+      for (int i = 0; i < entradas.length; i++) {
+        if (entradas[i] != null && entradas[i].getElementos() > 1) {
+          col += entradas[i].getElementos() - 1;
+        }
+      }
+      return col;
     }
 
     /**
@@ -195,7 +302,15 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @return el máximo número de colisiones para una misma llave.
      */
     public int colisionMaxima() {
-        // Aquí va su código.
+      int col = 0;
+      for (int i = 0; i < entradas.length; i++) {
+        if (entradas[i] != null) {
+          if ((entradas[i].getElementos() - 1) > col) {
+            col += entradas[i].getElementos() - 1;
+          }
+        }
+      }
+      return col;
     }
 
     /**
@@ -203,7 +318,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @return la carga del diccionario.
      */
     public double carga() {
-        // Aquí va su código.
+      return (double)((elementos + 0.0)/entradas.length);
     }
 
     /**
@@ -211,7 +326,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @return el número de entradas en el diccionario.
      */
     public int getElementos() {
-        // Aquí va su código.
+      return elementos;
     }
 
     /**
@@ -220,14 +335,15 @@ public class Diccionario<K, V> implements Iterable<V> {
      *         en otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+      return elementos == 0;
     }
 
     /**
      * Limpia el diccionario de elementos, dejándolo vacío.
      */
     public void limpia() {
-        // Aquí va su código.
+        entradas = nuevoArreglo(elementos);
+        elementos = 0;
     }
 
     /**
@@ -235,7 +351,19 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @return una representación en cadena del diccionario.
      */
     @Override public String toString() {
-        // Aquí va su código.
+      String dic = "{ ";
+      for (Lista<Entrada> lista : entradas) {
+        if (lista != null) {
+          for (Entrada e : lista) {
+            dic += "'" + e.llave + "'" + ": '" + e.valor + "', ";
+          }
+        }
+      }
+      if (dic.equals("{ ")) {
+        return "{}";
+      }
+      dic += "}";
+      return dic;
     }
 
     /**
@@ -248,9 +376,30 @@ public class Diccionario<K, V> implements Iterable<V> {
     @Override public boolean equals(Object o) {
         if (o == null || getClass() != o.getClass())
             return false;
-        @SuppressWarnings("unchecked") Diccionario<K, V> d =
-            (Diccionario<K, V>)o;
-        // Aquí va su código.
+        @SuppressWarnings("unchecked") Diccionario<K, V> d = (Diccionario<K, V>)o;
+        Lista<K> ll = keys();
+        Lista<K> dic = d.keys();
+        if (ll.getLongitud() != dic.getLongitud()) {
+          return false;
+        }
+        for (K llaves : ll) {
+          if (!(d.contiene(llaves) && d.get(llaves).equals(get(llaves)))) {
+            return false;
+          }
+        }
+        return true;
+    }
+
+    private Lista<K> keys(){
+      Lista<K> k = new Lista<>();
+      for (Lista<Entrada> lista : entradas) {
+        if (lista != null) {
+          for (Entrada e : lista) {
+            k.agrega(e.llave);
+          }
+        }
+      }
+      return k;
     }
 
     /**
@@ -270,4 +419,5 @@ public class Diccionario<K, V> implements Iterable<V> {
     @Override public Iterator<V> iterator() {
         return new IteradorValores();
     }
+
 }
diff --git a/src/mx/unam/ciencias/edd/Dispersores.java b/src/mx/unam/ciencias/edd/Dispersores.java
index 0e35435..30881ad 100644
--- a/src/mx/unam/ciencias/edd/Dispersores.java
+++ b/src/mx/unam/ciencias/edd/Dispersores.java
@@ -14,7 +14,49 @@ public class Dispersores {
      * @return la dispersión de XOR de la llave.
      */
     public static int dispersaXOR(byte[] llave) {
-        // Aquí va su código.
+      int r = 0;
+      int i = 0;
+      int l = llave.length;
+      while (l >= 4) {
+        r ^= combinaBE(llave[i], llave[i+1], llave[i+2], llave[i+3]);
+        i += 4;
+        l -= 4;
+      }
+      int t = 0;
+      switch (l) {
+        case 3:
+          t |= (llave[i+2] & 0xFF) << 8;
+        case 2:
+          t |= (llave[i+1] & 0xFF) << 16;
+        case 1:
+          t |= (llave[i] & 0xFF)   << 24;
+      }
+      r ^= t;
+      return r;
+    }
+
+    /**
+     * Metodo privado que realiza bigEndien
+     * @param a primer byte
+     * @param b segundo byte
+     * @param c tercer byte
+     * @param d cuarto byte
+     * @return int - cuarto bytes convertidos en un entero;
+     */
+    private static int combinaBE(byte a, byte b, byte c, byte d){
+      return ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((c & 0xFF) << 8) | ((d & 0xFF));
+    }
+
+    /**
+    * Metodo privado que realiza bigEndien
+    * @param a primer byte
+    * @param b segundo byte
+    * @param c tercer byte
+    * @param d cuarto byte
+    * @return int - cuarto bytes convertidos en un entero;
+     */
+    private static   int combinaLE(byte a, byte b, byte c, byte d){
+      return ((a & 0xFF)) + ((b & 0xFF) << 8) + ((c & 0xFF) << 16) + ((d & 0xFF) << 24);
     }
 
     /**
@@ -23,15 +65,85 @@ public class Dispersores {
      * @return la dispersión de Bob Jenkins de la llave.
      */
     public static int dispersaBJ(byte[] llave) {
-        // Aquí va su código.
+      int a = 0x9e3779B9;
+      int b = 0x9e3779b9;
+      int c = 0xFFFFFFFF;
+      int l = llave.length;
+      int i = 0;
+      int[] r;
+      while (l >= 12) {
+        a += combinaLE(llave[i], llave[i + 1], llave[i + 2], llave[i + 3]);
+        b += combinaLE(llave[i + 4], llave[i + 5], llave[i + 6], llave[i + 7]);
+        c += combinaLE(llave[i + 8], llave[i + 9], llave[i + 10], llave[i + 11]);
+        r = meclaJenkings(a, b, c);
+        a = r[0];
+        b = r[1];
+        c = r[2];
+        l -= 12;
+        i += 12;
+      }
+      c += llave.length;
+      switch (l) {
+        case 11:
+          c += (llave[i + 10] & 0xFF) << 24;
+        case 10:
+          c += (llave[i + 9] & 0xFF) << 16;
+        case 9:
+          c += (llave[i + 8] & 0XFF) << 8;
+        case 8:
+          b += (llave[i + 7] & 0xFF) << 24;
+        case 7:
+          b += (llave[i + 6] & 0xFF) << 16;
+        case 6:
+          b += (llave[i + 5] & 0xFF) << 8;
+        case 5:
+          b += (llave[i + 4] & 0xFF);
+        case 4:
+          a += (llave[i + 3] & 0xFF) << 24;
+        case 3:
+          a += (llave[i + 2] & 0xFF) << 16;
+        case 2:
+          a += (llave[i + 1] & 0xFF) << 8;
+        case 1:
+          a += (llave[i] & 0xFF);
+          break;
+
+      }
+      r = meclaJenkings(a, b, c);
+      return r[2];
     }
 
     /**
+     * Metodo para mezclar tres bytes
+     * @param a primer byte a mezclar
+     * @param b segundo byte a mezclar
+     * @param c tercer byte a mezclar
+     */
+     private static int[] meclaJenkings(int a, int b, int c){
+       a -= b; a -= c; a ^= (c >>> 13);
+       b -= c; b -= a; b ^= (a << 8);
+       c -= a; c -= b; c ^= (b >>> 13);
+       a -= b; a -= c; a ^= (c >>> 12);
+       b -= c; b -= a; b ^= (a << 16);
+       c -= a; c -= b; c ^= (b >>> 5);
+       a -= b; a -= c; a ^= (c >>> 3);
+       b -= c; b -= a; b ^= (a << 10);
+       c -= a; c -= b; c ^= (b >>> 15);
+       int[] r = {a,b,c};
+       return r;
+     }
+
+
+    /**
      * Función de dispersión Daniel J. Bernstein.
      * @param llave la llave a dispersar.
      * @return la dispersión de Daniel Bernstein de la llave.
      */
     public static int dispersaDJB(byte[] llave) {
-        // Aquí va su código.
+        int h = 5381;
+        for (int i = 0; i < llave.length; i++) {
+          h += (h << 5) + (llave[i] & 0xFF);
+        }
+        return h;
     }
 }
diff --git a/src/mx/unam/ciencias/edd/Grafica.java b/src/mx/unam/ciencias/edd/Grafica.java
index 8849831..9f75952 100644
--- a/src/mx/unam/ciencias/edd/Grafica.java
+++ b/src/mx/unam/ciencias/edd/Grafica.java
@@ -17,24 +17,23 @@ public class Grafica<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador, auxiliándose de la lista de vértices. */
         public Iterador() {
-            // Aquí va su código.
+	         iterador = vertices.iterator();
         }
 
         /* Nos dice si hay un siguiente elemento. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+	         return iterador.hasNext();
         }
 
         /* Regresa el siguiente elemento. */
         @Override public T next() {
-            // Aquí va su código.
+	         return iterador.next().elemento;
         }
     }
 
     /* Vertices para gráficas; implementan la interfaz ComparableIndexable y
      * VerticeGrafica */
-    private class Vertice implements VerticeGrafica<T>,
-                          ComparableIndexable<Vertice> {
+    private class Vertice implements VerticeGrafica<T>, ComparableIndexable<Vertice> {
 
         /* El elemento del vértice. */
         public T elemento;
@@ -49,42 +48,50 @@ public class Grafica<T> implements Coleccion<T> {
 
         /* Crea un nuevo vértice a partir de un elemento. */
         public Vertice(T elemento) {
-            // Aquí va su código.
+	         this.elemento = elemento;
+           color = Color.NINGUNO;
+           vecinos = new Diccionario<>();
+
         }
 
         /* Regresa el elemento del vértice. */
         @Override public T get() {
-            // Aquí va su código.
+	         return elemento;
         }
 
         /* Regresa el grado del vértice. */
         @Override public int getGrado() {
-            // Aquí va su código.
+	         return vecinos.getElementos();
         }
 
         /* Regresa el color del vértice. */
         @Override public Color getColor() {
-            // Aquí va su código.
+	         return color;
         }
 
         /* Regresa un iterable para los vecinos. */
         @Override public Iterable<? extends VerticeGrafica<T>> vecinos() {
-            // Aquí va su código.
+	         return vecinos;
         }
 
         /* Define el índice del vértice. */
         @Override public void setIndice(int indice) {
-            // Aquí va su código.
+          this.indice = indice;
         }
 
         /* Regresa el índice del vértice. */
         @Override public int getIndice() {
-            // Aquí va su código.
+          return indice;
         }
 
         /* Compara dos vértices por distancia. */
         @Override public int compareTo(Vertice vertice) {
-            // Aquí va su código.
+          if (distancia < vertice.distancia) {
+            return -1;
+          } else if (distancia > vertice.distancia) {
+            return 1;
+          }
+          return 0;
         }
     }
 
@@ -100,27 +107,28 @@ public class Grafica<T> implements Coleccion<T> {
         /* Construye un nuevo vecino con el vértice recibido como vecino y el
          * peso especificado. */
         public Vecino(Vertice vecino, double peso) {
-            // Aquí va su código.
+          this.vecino = vecino;
+          this.peso = peso;
         }
 
         /* Regresa el elemento del vecino. */
         @Override public T get() {
-            // Aquí va su código.
+          return vecino.elemento;
         }
 
         /* Regresa el grado del vecino. */
         @Override public int getGrado() {
-            // Aquí va su código.
+          return vecino.getGrado();
         }
 
         /* Regresa el color del vecino. */
         @Override public Color getColor() {
-            // Aquí va su código.
+          return vecino.color;
         }
 
         /* Regresa un iterable para los vecinos del vecino. */
         @Override public Iterable<? extends VerticeGrafica<T>> vecinos() {
-            // Aquí va su código.
+          return vecino.vecinos;
         }
     }
 
@@ -141,7 +149,8 @@ public class Grafica<T> implements Coleccion<T> {
      * Constructor único.
      */
     public Grafica() {
-        // Aquí va su código.
+	     vertices = new Diccionario<>();
+       aristas = 0;
     }
 
     /**
@@ -150,7 +159,7 @@ public class Grafica<T> implements Coleccion<T> {
      * @return el número de elementos en la gráfica.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+	     return vertices.getElementos();
     }
 
     /**
@@ -158,7 +167,7 @@ public class Grafica<T> implements Coleccion<T> {
      * @return el número de aristas.
      */
     public int getAristas() {
-        // Aquí va su código.
+	     return aristas;
     }
 
     /**
@@ -168,7 +177,11 @@ public class Grafica<T> implements Coleccion<T> {
      *         la gráfica.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+	     if(elemento == null || contiene(elemento)){
+	        throw new IllegalArgumentException();
+	       }
+	        Vertice vertice = new Vertice(elemento);
+          vertices.agrega(elemento, vertice);
     }
 
     /**
@@ -181,7 +194,17 @@ public class Grafica<T> implements Coleccion<T> {
      *         igual a b.
      */
     public void conecta(T a, T b) {
-        // Aquí va su código.
+       if(!contiene(a) || !contiene(b)){
+         throw new NoSuchElementException();
+	      }
+       if(a.equals(b) || sonVecinos(a, b)){
+         throw new IllegalArgumentException();
+	      }
+        Vertice verticeA = (Vertice)vertice(a);
+        Vertice verticeB = (Vertice)vertice(b);
+        verticeA.vecinos.agrega(verticeB.elemento, new Vecino(verticeB, 1));
+        verticeB.vecinos.agrega(verticeA.elemento, new Vecino(verticeA, 1));
+        aristas++;
     }
 
     /**
@@ -195,7 +218,17 @@ public class Grafica<T> implements Coleccion<T> {
      *         igual a b, o si el peso es no positivo.
      */
     public void conecta(T a, T b, double peso) {
-        // Aquí va su código.
+      if(!contiene(a) || !contiene(b)){
+        throw new NoSuchElementException("a o b no se encuentran en la grafica");
+       }
+      if(a.equals(b) || sonVecinos(a, b) || peso <= 0){
+        throw new IllegalArgumentException("a y b ya estan conectados");
+       }
+       Vertice verticeA = (Vertice)vertice(a);
+       Vertice verticeB = (Vertice)vertice(b);
+       verticeA.vecinos.agrega(verticeB.elemento, new Vecino(verticeB, peso));
+       verticeB.vecinos.agrega(verticeA.elemento, new Vecino(verticeA, peso));
+       aristas++;
     }
 
     /**
@@ -207,7 +240,29 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si a o b no están conectados.
      */
     public void desconecta(T a, T b) {
-        // Aquí va su código.
+      if(!contiene(a) || !contiene(b)){
+        throw new NoSuchElementException();
+      }
+      if(!sonVecinos(a,b)){
+        throw new IllegalArgumentException();
+      }
+      Vertice verticeA = (Vertice)vertice(a);
+      Vertice verticeB = (Vertice)vertice(b);
+      Vecino vertexA = null;
+      Vecino vertexB = null;
+      for (Vecino v : verticeA.vecinos) {
+        if (v.vecino.equals(verticeB)) {
+            vertexA = v;
+        }
+      }
+      for (Vecino v : verticeB.vecinos) {
+        if (v.vecino.equals(verticeA)) {
+          vertexB = v;
+        }
+      }
+      verticeA.vecinos.elimina(vertexA.vecino.elemento);
+      verticeB.vecinos.elimina(vertexB.vecino.elemento);
+      aristas--;
     }
 
     /**
@@ -216,7 +271,16 @@ public class Grafica<T> implements Coleccion<T> {
      *         <tt>false</tt> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+    	boolean contenido = false;
+    	for(Vertice v : vertices){
+    	    if(elemento == null){
+    		contenido = false;
+    	    }
+    	    if(v.elemento.equals(elemento)){
+    		contenido = true;
+    	    }
+    	}
+    	return contenido;
     }
 
     /**
@@ -227,7 +291,18 @@ public class Grafica<T> implements Coleccion<T> {
      *         gráfica.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+      if (!contiene(elemento))
+            throw new NoSuchElementException("El elemento no está contenido en la gráfica.");
+        Vertice v = (Vertice)vertice(elemento);
+        for (Vertice vertex : vertices){
+            for (Vecino n : vertex.vecinos){
+                if (n.vecino.equals(v)) {
+                    vertex.vecinos.elimina(n.vecino.elemento);
+                    aristas--;
+                }
+            }
+        }
+        vertices.elimina(v.elemento);
     }
 
     /**
@@ -239,7 +314,18 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws NoSuchElementException si a o b no son elementos de la gráfica.
      */
     public boolean sonVecinos(T a, T b) {
-        // Aquí va su código.
+      if(!contiene(a) || !contiene(b)){
+        throw new NoSuchElementException("a o b no se encuentran en la grafica");
+      }
+    	Vertice verticeA = (Vertice)vertice(a);
+    	Vertice verticeB = (Vertice)vertice(b);
+    	boolean ngs = false;
+    	for (Vecino vertice : verticeA.vecinos) {
+        if (vertice.vecino.equals(verticeB)) {
+          ngs = true;
+        }
+      }
+    	return ngs;
     }
 
     /**
@@ -253,7 +339,20 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si a o b no están conectados.
      */
     public double getPeso(T a, T b) {
-        // Aquí va su código.
+      if (!contiene(a) || !contiene(b)) {
+        throw new NoSuchElementException("Los elementos o se encuentran en la grafica");
+      }
+      if (!sonVecinos(a, b)) {
+        throw new IllegalArgumentException("No son vecinos");
+      }
+      Vertice verticeA = (Vertice)vertice(a);
+      Vertice verticeB = (Vertice)vertice(b);
+      for (Vecino v : verticeA.vecinos) {
+        if (v.vecino.equals(verticeB)) {
+          return v.peso;
+        }
+      }
+      return -1;
     }
 
     /**
@@ -268,7 +367,25 @@ public class Grafica<T> implements Coleccion<T> {
      *         es menor o igual que cero.
      */
     public void setPeso(T a, T b, double peso) {
-        // Aquí va su código.
+      if (!contiene(a) || !contiene(b)) {
+        throw new NoSuchElementException("No son elementos de la grafica");
+      }
+      if (!sonVecinos(a, b) || peso <= 0) {
+        throw new IllegalArgumentException("a y b no estan conectados");
+      }
+      Vertice verticeA = (Vertice)vertice(a);
+      Vertice verticeB = (Vertice)vertice(b);
+      for (Vecino v : verticeA.vecinos) {
+        if (v.vecino.equals(verticeB)) {
+          v.peso = peso;
+        }
+      }
+      for (Vecino v : verticeB.vecinos) {
+        if (v.vecino.equals(verticeA)) {
+          v.peso = peso;
+        }
+      }
+      peso = -1;
     }
 
     /**
@@ -278,7 +395,12 @@ public class Grafica<T> implements Coleccion<T> {
      * @return el vértice correspondiente el elemento recibido.
      */
     public VerticeGrafica<T> vertice(T elemento) {
-        // Aquí va su código.
+      for(Vertice v : vertices){
+         if(v.elemento.equals(elemento)){
+       return v;
+         }
+     }
+     throw new NoSuchElementException("El elemento no esta en al grafica");
     }
 
     /**
@@ -288,7 +410,18 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si el vértice no es válido.
      */
     public void setColor(VerticeGrafica<T> vertice, Color color) {
-        // Aquí va su código.
+      if (vertice == null) {
+        throw new IllegalArgumentException("Vertice invalido");
+      }
+      if (vertice.getClass() == Vertice.class) {
+        Vertice v1 = (Vertice)vertice;
+        v1.color = color;
+      } else if (vertice.getClass() == Vecino.class) {
+        Vecino v2 = (Vecino)vertice;
+        v2.vecino.color = color;
+      } else {
+        throw new IllegalArgumentException("Vertice Invalido");
+      }
     }
 
     /**
@@ -297,16 +430,41 @@ public class Grafica<T> implements Coleccion<T> {
      *         otro caso.
      */
     public boolean esConexa() {
-        // Aquí va su código.
+	     Cola<Vertice> c = new Cola<>();
+        Vertice v = null;
+        for (Vertice va : vertices) {
+          v = va;
+          break;
+        }
+        c.mete(v);
+        while(!c.esVacia()){
+          Vertice aux = c.saca();
+          aux.color = Color.ROJO;
+          for(Vecino v2 : aux.vecinos){
+            if(v2.vecino.color != Color.ROJO){
+              v2.vecino.color = Color.ROJO;
+              c.mete(v2.vecino);
+            }
+          }
+        }
+        for(Vertice v2 : vertices){
+          if(v2.color != Color.ROJO){
+            return false;
+          }
+          v2.color = Color.NINGUNO;
+        }
+        return true;
     }
 
     /**
-     * Realiza la acción recibida en cada uno de los vértices de la gráfica, en
+     * Realiza la acción recibida en cada uno de los vértices de la gráfica, en c
      * el orden en que fueron agregados.
      * @param accion la acción a realizar.
      */
     public void paraCadaVertice(AccionVerticeGrafica<T> accion) {
-        // Aquí va su código.
+    	for(Vertice v : vertices){
+    	    accion.actua(v);
+    	}
     }
 
     /**
@@ -320,10 +478,41 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el elemento no está en la gráfica.
      */
     public void bfs(T elemento, AccionVerticeGrafica<T> accion) {
-        // Aquí va su código.
+      Cola<Vertice> cola = new Cola<>();
+      recorre(elemento, accion, cola);
     }
 
     /**
+     * Metodo auxiliar par bfs y dfs que recorre la grafica
+     * @param elemento el elemento sobre cuyo vértice queremos comenzar el
+     *                 recorrido.
+     * @param accion la acción a realizar.
+     * @param metesaca estructura de la instancia MeteSaca.
+     * @throws NoSuchElementException si el elemento no se encuentra en la gráfica
+     */
+     private void recorre(T elemento, AccionVerticeGrafica<T> accion, MeteSaca<Vertice> metesaca) throws NoSuchElementException{
+       if (!contiene(elemento)) {
+         throw new NoSuchElementException();
+       }
+       Vertice vertice = (Vertice)vertice(elemento);
+       vertice.color = Color.NEGRO;
+       metesaca.mete(vertice);
+       while (!metesaca.esVacia()) {
+         Vertice v = metesaca.saca();
+         v.color = Color.NEGRO;
+         accion.actua(v);
+         for (Vecino a : v.vecinos) {
+           if (a.vecino.color != Color.NEGRO) {
+             a.vecino.color = Color.NEGRO;
+             metesaca.mete(a.vecino);
+           }
+         }
+       }
+       paraCadaVertice(ver -> setColor(ver, Color.NINGUNO));
+     }
+
+
+    /**
      * Realiza la acción recibida en todos los vértices de la gráfica, en el
      * orden determinado por DFS, comenzando por el vértice correspondiente al
      * elemento recibido. Al terminar el método, todos los vértices tendrán
@@ -334,7 +523,8 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el elemento no está en la gráfica.
      */
     public void dfs(T elemento, AccionVerticeGrafica<T> accion) {
-        // Aquí va su código.
+      Pila<Vertice> pila = new Pila<>();
+      recorre(elemento, accion, pila);
     }
 
     /**
@@ -343,14 +533,15 @@ public class Grafica<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+	     return vertices.esVacia();
     }
 
     /**
      * Limpia la gráfica de vértices y aristas, dejándola vacía.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+    	vertices.limpia();
+    	aristas = 0;
     }
 
     /**
@@ -358,7 +549,15 @@ public class Grafica<T> implements Coleccion<T> {
      * @return una representación en cadena de la gráfica.
      */
     @Override public String toString() {
-        // Aquí va su código.
+    	String s = "";
+          for(Vertice v : vertices){
+            for(Vecino v2 : v.vecinos){
+              if(!s.contains("(" + v2.vecino.elemento + ", " + v.elemento)){
+                s += "(" + v.elemento.toString() + ", " + v2.vecino.elemento.toString() + "), ";
+              }
+            }
+          }
+          return s;
     }
 
     /**
@@ -371,7 +570,20 @@ public class Grafica<T> implements Coleccion<T> {
         if (o == null || getClass() != o.getClass())
             return false;
         @SuppressWarnings("unchecked") Grafica<T> grafica = (Grafica<T>)o;
-        // Aquí va su código.
+       if(aristas != grafica.aristas || vertices.getElementos() != grafica.vertices.getElementos()){
+          return false;
+        }
+        for(Vertice v : vertices){
+          if(!grafica.contiene(v.elemento)){
+            return false;
+          }
+          for(Vecino v2 : v.vecinos){
+            if(!grafica.sonVecinos(v.elemento, v2.vecino.elemento)){
+              return false;
+            }
+          }
+        }
+        return true;
     }
 
     /**
@@ -395,7 +607,50 @@ public class Grafica<T> implements Coleccion<T> {
      *         la gráfica.
      */
     public Lista<VerticeGrafica<T>> trayectoriaMinima(T origen, T destino) {
-        // Aquí va su código.
+      if (!contiene(origen) || !contiene(destino)) {
+        throw new NoSuchElementException("No estan en la grafica");
+      }
+      Lista<VerticeGrafica<T>> lista = new Lista<>();
+
+      Vertice verticeOrigen = (Vertice)vertice(origen);
+      Vertice verticeDestino = (Vertice)vertice(destino);
+      if (verticeOrigen.equals(verticeDestino)) {
+        lista.agrega(verticeDestino);
+        return lista;
+      }
+      for (Vertice v : vertices) {
+        v.distancia = Double.POSITIVE_INFINITY;
+      }
+      verticeOrigen.distancia = 0;
+
+      MonticuloMinimo<Vertice> mn = new MonticuloMinimo<>(vertices, vertices.getElementos());
+      while(!mn.esVacia()){
+        Vertice u = mn.elimina();
+        for (Vecino v : u.vecinos) {
+          if (v.vecino.distancia == Double.POSITIVE_INFINITY || u.distancia + v.peso < v.vecino.distancia) {
+            v.vecino.distancia = u.distancia + 1;
+            mn.reordena(v.vecino);
+          }
+        }
+      }
+
+      if(verticeDestino.distancia != Double.POSITIVE_INFINITY){
+        Vertice aux = verticeDestino;
+
+        while (!aux.equals(verticeOrigen)) {
+          for (Vecino vec : aux.vecinos) {
+            if (aux.distancia - 1 == vec.vecino.distancia) {
+              lista.agregaInicio(aux);
+              aux = vec.vecino;
+              break;
+            }
+          }
+          if (aux.equals(verticeOrigen)) {
+            lista.agregaInicio(verticeOrigen);
+          }
+        }
+      }
+      return lista;
     }
 
     /**
@@ -410,6 +665,51 @@ public class Grafica<T> implements Coleccion<T> {
      *         la gráfica.
      */
     public Lista<VerticeGrafica<T>> dijkstra(T origen, T destino) {
-        // Aquí va su código.
+      if (!contiene(origen) || !contiene(destino)) {
+        throw new NoSuchElementException("No estan en la grafica");
+      }
+      Lista<VerticeGrafica<T>> lista = new Lista<>();
+
+      Vertice verticeOrigen = (Vertice)vertice(origen);
+      Vertice verticeDestino = (Vertice)vertice(destino);
+      if (verticeOrigen.equals(verticeDestino)) {
+        lista.agrega(verticeDestino);
+        return lista;
+      }
+      for (Vertice v : vertices) {
+        v.distancia = Double.POSITIVE_INFINITY;
+      }
+      verticeOrigen.distancia = 0;
+
+      MonticuloMinimo<Vertice> mn = new MonticuloMinimo<>(vertices, vertices.getElementos());
+      while(!mn.esVacia()){
+        Vertice u = mn.elimina();
+        for (Vecino v : u.vecinos) {
+          if (v.vecino.distancia == Double.POSITIVE_INFINITY || u.distancia + v.peso < v.vecino.distancia) {
+            v.vecino.distancia = u.distancia + v.peso;
+            mn.reordena(v.vecino);
+          }
+        }
+      }
+
+      if(verticeDestino.distancia != Double.POSITIVE_INFINITY){
+        Vertice aux = verticeDestino;
+
+        while (!aux.equals(verticeOrigen)) {
+          for (Vecino vec : aux.vecinos) {
+            if (aux.distancia - vec.peso == vec.vecino.distancia) {
+              lista.agregaInicio(aux);
+              aux = vec.vecino;
+              break;
+            }
+          }
+          if (aux.equals(verticeOrigen)) {
+            lista.agregaInicio(verticeOrigen);
+          }
+        }
+      }
+      return lista;
     }
+
+
 }
diff --git a/src/mx/unam/ciencias/edd/Indexable.java b/src/mx/unam/ciencias/edd/Indexable.java
index fa5ead0..5f3198c 100644
--- a/src/mx/unam/ciencias/edd/Indexable.java
+++ b/src/mx/unam/ciencias/edd/Indexable.java
@@ -18,7 +18,9 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
      * @param valor su valor.
      */
     public Indexable(T elemento, double valor) {
-        // Aquí va su código.
+      this.elemento = elemento;
+      this.valor = valor;
+      indice = -1;
     }
 
     /**
@@ -26,7 +28,7 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
      * @return el elemento del indexable.
      */
     public T getElemento() {
-        // Aquí va su código.
+      return elemento;
     }
 
     /**
@@ -37,7 +39,13 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
      *         es mayor.
      */
     @Override public int compareTo(Indexable<T> indexable) {
-        // Aquí va su código.
+      int v = 0;
+      if(valor < indexable.getValor()){
+        v = -1;
+      } else if(valor > indexable.getValor()){
+        v = 1;
+      }
+      return v;
     }
 
     /**
@@ -45,7 +53,7 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
      * @param indice el nuevo índice.
      */
     @Override public void setIndice(int indice) {
-        // Aquí va su código.
+      this.indice = indice;
     }
 
     /**
@@ -53,7 +61,7 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
      * @return el índice del indexable.
      */
     @Override public int getIndice() {
-        // Aquí va su código.
+      return indice;
     }
 
     /**
@@ -61,7 +69,7 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
      * @param valor el nuevo valor.
      */
     public void setValor(double valor) {
-        // Aquí va su código.
+      this.valor = valor;
     }
 
     /**
@@ -69,7 +77,7 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
      * @return el valor del indexable.
      */
     public double getValor() {
-        // Aquí va su código.
+      return valor;
     }
 
     /**
@@ -81,9 +89,17 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
     @Override public boolean equals(Object o) {
         if (o == null || getClass() != o.getClass())
             return false;
-        @SuppressWarnings("unchecked") Indexable<T> indexable =
-            (Indexable<T>)o;
-        // Aquí va su código.
+        @SuppressWarnings("unchecked") Indexable<T> indexable = (Indexable<T>)o;
+        if (elemento != indexable.getElemento()) {
+          return false;
+        }
+        if (getIndice() != indexable.getIndice()) {
+          return false;
+        }
+        if (getValor() != indexable.getValor()) {
+          return false;
+        }
+        return true;
     }
 
     /**
@@ -91,6 +107,6 @@ public class Indexable<T> implements ComparableIndexable<Indexable<T>> {
      * @return una representación en cadena del indexable.
      */
     @Override public String toString() {
-        // Aquí va su código.
+      return String.format(elemento + ":%2.9f", valor);
     }
 }
diff --git a/src/mx/unam/ciencias/edd/Lista.java b/src/mx/unam/ciencias/edd/Lista.java
index 3850d41..7d8fb1a 100644
--- a/src/mx/unam/ciencias/edd/Lista.java
+++ b/src/mx/unam/ciencias/edd/Lista.java
@@ -25,9 +25,12 @@ public class Lista<T> implements Coleccion<T> {
         public Nodo siguiente;
 
         /* Construye un nodo con un elemento. */
-        public Nodo(T elemento) {
-            // Aquí va su código.
+        public Nodo(T elemento) throws IllegalArgumentException{
+            if(elemento == null)
+                throw new IllegalArgumentException("Elemento nulo");
+            this.elemento = elemento;
         }
+
     }
 
     /* Clase Iterador privada para iteradores. */
@@ -39,37 +42,47 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador. */
         public Iterador() {
-            // Aquí va su código.
+            start();
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return siguiente != null;
         }
 
         /* Nos da el elemento siguiente. */
-        @Override public T next() {
-            // Aquí va su código.
+        @Override public T next() throws NoSuchElementException {
+            if(siguiente == null)
+                throw new NoSuchElementException("Elemento nulo");
+            anterior = siguiente;
+            siguiente = siguiente.siguiente;
+            return anterior.elemento;
         }
 
         /* Nos dice si hay un elemento anterior. */
         @Override public boolean hasPrevious() {
-            // Aquí va su código.
+            return anterior != null;
         }
 
         /* Nos da el elemento anterior. */
-        @Override public T previous() {
-            // Aquí va su código.
+        @Override public T previous() throws NoSuchElementException {
+            if(anterior == null)
+                throw new NoSuchElementException("Elemento nulo");
+            siguiente = anterior;
+            anterior = anterior.anterior;
+            return siguiente.elemento;
         }
 
         /* Mueve el iterador al inicio de la lista. */
         @Override public void start() {
-            // Aquí va su código.
+            siguiente = cabeza;
+            anterior = null;
         }
 
         /* Mueve el iterador al final de la lista. */
         @Override public void end() {
-            // Aquí va su código.
+            anterior = rabo;
+            siguiente = null;
         }
     }
 
@@ -86,16 +99,16 @@ public class Lista<T> implements Coleccion<T> {
      * @return la longitud de la lista, el número de elementos que contiene.
      */
     public int getLongitud() {
-        // Aquí va su código.
+        return getElementos();
     }
 
     /**
-     * Regresa el número elementos en la lista. El método es idéntico a {@link
+     * Regresa el número apelementos en la lista. El método es idéntico a {@link
      * #getLongitud}.
      * @return el número elementos en la lista.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return longitud;
     }
 
     /**
@@ -104,7 +117,7 @@ public class Lista<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -115,8 +128,19 @@ public class Lista<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override public void agrega(T elemento) throws IllegalArgumentException{
+        if (elemento == null) {
+            throw new IllegalArgumentException("Elemento nulo");
+        }
+        Nodo n = new Nodo(elemento);
+        if (cabeza == null) {
+            cabeza = rabo = n;
+        } else {
+            rabo.siguiente = n;
+            n.anterior = rabo;
+            rabo = n;
+        }
+        longitud++;
     }
 
     /**
@@ -127,7 +151,7 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaFinal(T elemento) {
-        // Aquí va su código.
+        agrega(elemento);
     }
 
     /**
@@ -137,8 +161,19 @@ public class Lista<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    public void agregaInicio(T elemento) {
-        // Aquí va su código.
+    public void agregaInicio(T elemento) throws IllegalArgumentException{
+        if (elemento == null) {
+            throw new IllegalArgumentException("Elemento nulo");
+        }
+        Nodo n = new Nodo(elemento);
+        if (cabeza == null) {
+            cabeza = rabo = n;
+        } else {
+            cabeza.anterior = n;
+            n.siguiente = cabeza;
+            cabeza = n;
+        }
+        longitud++;
     }
 
     /**
@@ -146,7 +181,7 @@ public class Lista<T> implements Coleccion<T> {
      *
      * Si el índice es menor o igual que cero, el elemento se agrega al inicio
      * de la lista. Si el índice es mayor o igual que el número de elementos en
-     * la lista, el elemento se agrega al fina de la misma. En otro caso,
+     * la lista, el elemento se agrega al final de la misma. En otro caso,
      * después de mandar llamar el método, el elemento tendrá el índice que se
      * especifica en la lista.
      * @param i el índice dónde insertar el elemento. Si es menor que 0 el
@@ -156,26 +191,84 @@ public class Lista<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    public void inserta(int i, T elemento) {
-        // Aquí va su código.
+    public void inserta(int i, T elemento) throws IllegalArgumentException{
+        if (elemento == null) { throw new IllegalArgumentException("Elemento nulo"); }
+        if (i <= 0) {
+            agregaInicio(elemento);
+        } else if (i >= getElementos()) {
+            agregaFinal(elemento);
+        } else {
+            Nodo n = new Nodo(elemento);
+            Nodo s = iesimoNodo(i);
+            n.anterior = s.anterior;
+            s.anterior.siguiente = n;
+            n.siguiente = s;
+            s.anterior = n;
+            longitud++;
+        }
     }
 
     /**
+     * Metodo que regresa el i-esimo nodo de la lista
+     * @param i indice del nodo a buscar
+     * @return el i-esimo nodo
+     */
+    private Nodo iesimoNodo(int i){
+      if (cabeza == null) {
+          return null;
+      } else {
+          Nodo n2 = cabeza;
+          int a = 0;
+          while (a < i && n2.siguiente != null) {
+              n2 = n2.siguiente;
+              a++;
+          }
+          if (a != i)
+              return null;
+          return n2;
+      }
+    }
+    /**
      * Elimina un elemento de la lista. Si el elemento no está contenido en la
      * lista, el método no la modifica.
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        Nodo nodo = buscarNodo(elemento, cabeza);
+        if (nodo == null) {
+            return;
+        } else if (cabeza == rabo) {
+            cabeza = rabo = null;
+        } else if (cabeza == nodo) {
+            cabeza = cabeza.siguiente;
+            cabeza.anterior = null;
+        } else if (rabo == nodo) {
+            rabo = rabo.anterior;
+            rabo.siguiente = null;
+        } else {
+            nodo.siguiente.anterior = nodo.anterior;
+            nodo.anterior.siguiente = nodo.siguiente;
+        }
+        longitud--;
     }
 
+
     /**
      * Elimina el primer elemento de la lista y lo regresa.
      * @return el primer elemento de la lista antes de eliminarlo.
      * @throws NoSuchElementException si la lista es vacía.
      */
-    public T eliminaPrimero() {
-        // Aquí va su código.
+    public T eliminaPrimero() throws NoSuchElementException{
+        if (cabeza == null){ throw new NoSuchElementException("La lista no tiene elementos"); }
+        T elem = cabeza.elemento;
+        if (cabeza == rabo) {
+            cabeza = rabo = null;
+        } else {
+            cabeza = cabeza.siguiente;
+            cabeza.anterior = null;
+        }
+        longitud--;
+        return elem;
     }
 
     /**
@@ -183,8 +276,17 @@ public class Lista<T> implements Coleccion<T> {
      * @return el último elemento de la lista antes de eliminarlo.
      * @throws NoSuchElementException si la lista es vacía.
      */
-    public T eliminaUltimo() {
-        // Aquí va su código.
+    public T eliminaUltimo() throws NoSuchElementException{
+        if (cabeza == null){ throw new NoSuchElementException("La lista no tiene elementos"); }
+            T elem = rabo.elemento;
+        if (cabeza == rabo) {
+            cabeza = rabo = null;
+        } else {
+            rabo = rabo.anterior;
+            rabo.siguiente = null;
+        }
+        longitud--;
+        return elem;
     }
 
     /**
@@ -194,7 +296,18 @@ public class Lista<T> implements Coleccion<T> {
      *         <tt>false</tt> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        return buscarNodo(elemento, cabeza) != null;
+    }
+
+    /**
+     * Busca un elemento dentro de la lista de manera recursiva
+     * @param elemento elemento que se va a buscar
+     */
+    private Nodo buscarNodo(T elemento, Nodo nodo){
+        if (nodo == null || nodo.elemento.equals(elemento)) {
+            return nodo;
+        }
+        return buscarNodo(elemento, nodo.siguiente);
     }
 
     /**
@@ -202,23 +315,53 @@ public class Lista<T> implements Coleccion<T> {
      * @return una nueva lista que es la reversa la que manda llamar el método.
      */
     public Lista<T> reversa() {
-        // Aquí va su código.
+        Lista<T> lista = new Lista<>();
+        return reversa_0(lista, cabeza);
+    }
+
+    /**
+     * Metodo recursivo para invertir los elementos de una lista
+     * @param lista lista que se va a invertir
+     * @param nodo nodo del cual se comenzara
+     * @return nueva lista con los elementos invertidos
+     */
+    private Lista <T> reversa_0(Lista <T> lista, Nodo nodo){
+        if (nodo == null)
+            return lista;
+        lista.agregaInicio(nodo.elemento);
+        return reversa_0(lista, nodo.siguiente);
     }
 
     /**
      * Regresa una copia de la lista. La copia tiene los mismos elementos que la
      * lista que manda llamar el método, en el mismo orden.
-     * @return una copiad de la lista.
-     */
+     * @return una copia de la lista.
+     */ 
     public Lista<T> copia() {
-        // Aquí va su código.
+        Lista<T> lista = new Lista<T>();
+        return copia_0(lista, cabeza);
+    }
+
+    /**
+     * Metodo recursivo para copiar los elementos de una lista
+     * @param lista lista a la que se copiara el elemento
+     * @param nodo nodo del cual se comenzará a copiara
+     * @return nueva lista con los elemento copiados
+     */
+    private Lista<T> copia_0(Lista<T> lista, Nodo nodo){
+        if (nodo == null) {
+            return lista;
+        }
+        lista.agrega(nodo.elemento);
+        return copia_0(lista, nodo.siguiente);
     }
 
     /**
      * Limpia la lista de elementos, dejándola vacía.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        cabeza = rabo = null;
+        longitud = 0;
     }
 
     /**
@@ -226,17 +369,25 @@ public class Lista<T> implements Coleccion<T> {
      * @return el primer elemento de la lista.
      * @throws NoSuchElementException si la lista es vacía.
      */
-    public T getPrimero() {
-        // Aquí va su código.
+    public T getPrimero() throws NoSuchElementException{
+        if (cabeza == null){
+            throw new NoSuchElementException("La lista no tiene elementos");
+        } else {
+            return cabeza.elemento;
+        }
     }
 
     /**
      * Regresa el último elemento de la lista.
-     * @return el primer elemento de la lista.
+     * @return el último elemento de la lista.
      * @throws NoSuchElementException si la lista es vacía.
      */
-    public T getUltimo() {
-        // Aquí va su código.
+    public T getUltimo() throws NoSuchElementException{
+        if (cabeza == null){
+            throw new NoSuchElementException("La lista no tiene elementos");
+        } else {
+            return rabo.elemento;
+        }
     }
 
     /**
@@ -247,9 +398,12 @@ public class Lista<T> implements Coleccion<T> {
      *         igual que el número de elementos en la lista.
      */
     public T get(int i) {
-        // Aquí va su código.
+        if (i < 0 || i >= getElementos()) { throw new ExcepcionIndiceInvalido("Indice invalido"); }
+        Nodo s = iesimoNodo(i);
+        return s.elemento;
     }
 
+
     /**
      * Regresa el índice del elemento recibido en la lista.
      * @param elemento el elemento del que se busca el índice.
@@ -257,7 +411,14 @@ public class Lista<T> implements Coleccion<T> {
      *         el elemento no está contenido en la lista.
      */
     public int indiceDe(T elemento) {
-        // Aquí va su código.
+        Nodo nodo = cabeza;
+        for (int cont = 0; cont < getLongitud(); cont++) {
+            if (nodo.elemento.equals(elemento)) {
+                return cont;
+            }
+            nodo = nodo.siguiente;
+        }
+        return -1;
     }
 
     /**
@@ -265,7 +426,21 @@ public class Lista<T> implements Coleccion<T> {
      * @return una representación en cadena de la lista.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        Nodo nodo = cabeza;
+        String r;
+        if (nodo == null) {
+          r = "[]";
+        } else {
+          r = "[" + nodo.elemento;
+          for (int i = 1; i < getLongitud(); i++) {
+            if (nodo.siguiente != null) {
+              r += ", " + nodo.siguiente.elemento;
+            }
+            nodo = nodo.siguiente;
+          }
+          r += "]";
+        }
+        return r;
     }
 
     /**
@@ -278,7 +453,16 @@ public class Lista<T> implements Coleccion<T> {
         if (o == null || getClass() != o.getClass())
             return false;
         @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)o;
-        // Aquí va su código.
+        if (getLongitud() != lista.getLongitud()) { return false; }
+            Nodo nodo = cabeza;
+            Nodo nodo2 = lista.cabeza;
+            while (nodo != nodo2) {
+                if (!nodo.elemento.equals(nodo2.elemento))
+                    return false;
+                nodo = nodo.siguiente;
+                nodo2 = nodo2.siguiente;
+            }
+            return true;
     }
 
     /**
@@ -306,7 +490,42 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copia de la lista, pero ordenada.
      */
     public Lista<T> mergeSort(Comparator<T> comparador) {
-        // Aquí va su código.
+        if (longitud < 2) {
+            return copia();
+        }
+        Lista<T> li = new Lista<>(), ld = new Lista<>();
+        int i = 0;
+        for(T el : this){
+            Lista<T> ll = (i++ < longitud/2) ? li : ld;
+            ll.agrega(el);
+        }
+        return mezcla(li.mergeSort(comparador),ld.mergeSort(comparador),comparador);
+    }
+
+    private Lista<T> mezcla(Lista<T> listaizq, Lista<T> listader, Comparator<T> c) {
+        Lista<T> lista = new Lista<>();
+        Nodo nodo = listaizq.cabeza;
+        Nodo nodo2 = listader.cabeza;
+        while (nodo != null && nodo2 != null) {
+            if (c.compare(nodo.elemento, nodo2.elemento) <= 0) {
+                lista.agrega(nodo.elemento);
+                nodo = nodo.siguiente;
+            } else {
+                lista.agrega(nodo2.elemento);
+                nodo2 = nodo2.siguiente;
+            }
+        }
+        Nodo n;
+        if (nodo != null) {
+            n = nodo;
+        } else {
+            n = nodo2;
+        }
+        while (n != null) {
+            lista.agrega(n.elemento);
+            n = n.siguiente;
+        }
+        return lista;
     }
 
     /**
@@ -317,9 +536,8 @@ public class Lista<T> implements Coleccion<T> {
      * @param lista la lista que se ordenará.
      * @return una copia de la lista recibida, pero ordenada.
      */
-    public static <T extends Comparable<T>>
-    Lista<T> mergeSort(Lista<T> lista) {
-        // Aquí va su código.
+    public static <T extends Comparable<T>> Lista<T> mergeSort(Lista<T> lista) {
+        return lista.mergeSort((a, b) -> a.compareTo(b));
     }
 
     /**
@@ -331,7 +549,14 @@ public class Lista<T> implements Coleccion<T> {
      *         <tt>false</tt> en otro caso.
      */
     public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+        Nodo nodo = cabeza;
+        while (nodo != null) {
+            if (comparador.compare(nodo.elemento, elemento) == 0) {
+                return true;
+            }
+            nodo = nodo.siguiente;
+        }
+        return false;
     }
 
     /**
@@ -344,8 +569,8 @@ public class Lista<T> implements Coleccion<T> {
      * @return <tt>true</tt> si el elemento está contenido en la lista,
      *         <tt>false</tt> en otro caso.
      */
-    public static <T extends Comparable<T>>
-    boolean busquedaLineal(Lista<T> lista, T elemento) {
+    public static <T extends Comparable<T>> boolean busquedaLineal(Lista<T> lista, T elemento) {
         return lista.busquedaLineal(elemento, (a, b) -> a.compareTo(b));
     }
+
 }
diff --git a/src/mx/unam/ciencias/edd/MeteSaca.java b/src/mx/unam/ciencias/edd/MeteSaca.java
index 0bdcba3..43b1a3b 100644
--- a/src/mx/unam/ciencias/edd/MeteSaca.java
+++ b/src/mx/unam/ciencias/edd/MeteSaca.java
@@ -21,8 +21,11 @@ public abstract class MeteSaca<T> {
          * Construye un nodo con un elemento.
          * @param elemento el elemento del nodo.
          */
-        public Nodo(T elemento) {
-            // Aquí va su código.
+        public Nodo(T elemento) throws IllegalArgumentException{
+            if (elemento == null) {
+                throw new IllegalArgumentException("Elemento nulo");
+            }
+            this.elemento = elemento;
         }
     }
 
@@ -42,8 +45,16 @@ public abstract class MeteSaca<T> {
      * @return el elemento en un extremo de la estructura.
      * @throws NoSuchElementException si la estructura está vacía.
      */
-    public T saca() {
-        // Aquí va su código.
+    public T saca() throws NoSuchElementException {
+        if (cabeza == null) {
+            throw new NoSuchElementException("No hay elementos");
+        }
+        T elem = cabeza.elemento;
+        cabeza = cabeza.siguiente;
+        if (cabeza == null) {
+            rabo = null;
+        }
+        return elem;
     }
 
     /**
@@ -52,8 +63,11 @@ public abstract class MeteSaca<T> {
      * @return el elemento en un extremo de la estructura.
      * @throws NoSuchElementException si la estructura está vacía.
      */
-    public T mira() {
-        // Aquí va su código.
+    public T mira() throws NoSuchElementException{
+      if (cabeza == null) {
+        throw new NoSuchElementException("Descabezado");
+      }
+      return cabeza.elemento;
     }
 
     /**
@@ -62,7 +76,7 @@ public abstract class MeteSaca<T> {
      *         <tt>false</tt> en otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -76,6 +90,16 @@ public abstract class MeteSaca<T> {
         if (o == null || getClass() != o.getClass())
             return false;
         @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)o;
-        // Aquí va su código.
+        Nodo nodo = cabeza;
+        Nodo nodo2 = m.cabeza;
+        while (nodo != null && nodo2 != null) {
+            if (!nodo.elemento.equals(nodo2.elemento))
+                return false;
+            nodo = nodo.siguiente;
+            nodo2 = nodo2.siguiente;
+        }
+        if(nodo == nodo2)
+            return true;
+        return false;
     }
 }
diff --git a/src/mx/unam/ciencias/edd/MonticuloArreglo.java b/src/mx/unam/ciencias/edd/MonticuloArreglo.java
index 592c609..97dd489 100644
--- a/src/mx/unam/ciencias/edd/MonticuloArreglo.java
+++ b/src/mx/unam/ciencias/edd/MonticuloArreglo.java
@@ -5,8 +5,7 @@ import java.util.NoSuchElementException;
 /**
  * Clase para montículos de Dijkstra con arreglos.
  */
-public class MonticuloArreglo<T extends ComparableIndexable<T>>
-    implements MonticuloDijkstra<T> {
+public class MonticuloArreglo<T extends ComparableIndexable<T>> implements MonticuloDijkstra<T> {
 
     /* Número de elementos en el arreglo. */
     private int elementos;
@@ -27,7 +26,14 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      *                  montículo.
      */
     public MonticuloArreglo(Coleccion<T> coleccion) {
-        // Aquí va su código.
+      arreglo = nuevoArreglo(coleccion.getElementos());
+      elementos = coleccion.getElementos();
+      int j = 0;
+      for(T e : coleccion){
+        arreglo[j] = e;
+        arreglo[j].setIndice(j);
+        j++;
+      }
     }
 
     /**
@@ -37,16 +43,46 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      * @param n el número de elementos en el iterable.
      */
     public MonticuloArreglo(Iterable<T> iterable, int n) {
-        // Aquí va su código.
+      arreglo = nuevoArreglo(n);
+      elementos = n;
+      int j = 0;
+      for(T e : iterable){
+        arreglo[j] = e;
+        arreglo[j].setIndice(j);
+        j++;
+      }
     }
 
     /**
-     * Elimina el elemento mínimo del montículo.
+     * Elimina el elemento |mínimo del montículo.
      * @return el elemento mínimo del montículo.
      * @throws IllegalStateException si el montículo es vacío.
      */
     @Override public T elimina() {
-        // Aquí va su código.
+      if (esVacia()) {
+        throw new IllegalStateException();
+      }
+      T minimo = null;
+      int j = 0;
+      for (T e : arreglo) {
+        if (e != null) {
+          minimo = e;
+          break;
+        }
+        j++;
+      }
+      for (int i = j; i < arreglo.length; i++) {
+        if (arreglo[i] != null) {
+          if (arreglo[i].compareTo(minimo) < 0) {
+            minimo = arreglo[i];
+            j = i;
+          }
+        }
+      }
+      arreglo[j].setIndice(-1);
+      arreglo[j] = null;
+      elementos--;
+      return minimo;
     }
 
     /**
@@ -57,7 +93,10 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      *         que el número de elementos.
      */
     @Override public T get(int i) {
-        // Aquí va su código.
+      if (i < 0 || i >= getElementos()){
+        throw new NoSuchElementException();
+      }
+      return arreglo[i];
     }
 
     /**
@@ -66,7 +105,10 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      *         <tt>false</tt> en otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+      if (elementos == 0) {
+        return true;
+      }
+      return false;
     }
 
     /**
@@ -74,6 +116,6 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      * @return el número de elementos en el montículo.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return elementos;
     }
 }
diff --git a/src/mx/unam/ciencias/edd/MonticuloMinimo.java b/src/mx/unam/ciencias/edd/MonticuloMinimo.java
index da22395..aacfc89 100644
--- a/src/mx/unam/ciencias/edd/MonticuloMinimo.java
+++ b/src/mx/unam/ciencias/edd/MonticuloMinimo.java
@@ -6,8 +6,7 @@ import java.util.NoSuchElementException;
 /**
  * Clase para montículos mínimos (<i>min heaps</i>).
  */
-public class MonticuloMinimo<T extends ComparableIndexable<T>>
-    implements Coleccion<T>, MonticuloDijkstra<T> {
+public class MonticuloMinimo<T extends ComparableIndexable<T>> implements Coleccion<T>, MonticuloDijkstra<T> {
 
     /* Clase privada para iteradores de montículos. */
     private class Iterador implements Iterator<T> {
@@ -17,18 +16,23 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
 
         /* Nos dice si hay un siguiente elemento. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+          if (indice < arbol.length && arbol[indice] != null) {
+            return true;
+          }
+          return false;
         }
 
         /* Regresa el siguiente elemento. */
         @Override public T next() {
-            // Aquí va su código.
+          if (indice >= getElementos()) {
+            throw new NoSuchElementException();
+          }
+          return arbol[indice++];
         }
     }
 
     /* Clase estática privada para poder implementar HeapSort. */
-    private static class Adaptador<T  extends Comparable<T>>
-        implements ComparableIndexable<Adaptador<T>> {
+    private static class Adaptador<T  extends Comparable<T>> implements ComparableIndexable<Adaptador<T>> {
 
         /* El elemento. */
         private T elemento;
@@ -37,22 +41,29 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
 
         /* Crea un nuevo comparable indexable. */
         public Adaptador(T elemento) {
-            // Aquí va su código.
+          this.elemento = elemento;
+          indice = -1;
         }
 
         /* Regresa el índice. */
         @Override public int getIndice() {
-            // Aquí va su código.
+          return indice;
         }
 
         /* Define el índice. */
         @Override public void setIndice(int indice) {
-            // Aquí va su código.
+          this.indice = indice;
         }
 
         /* Compara un adaptador con otro. */
         @Override public int compareTo(Adaptador<T> adaptador) {
-            // Aquí va su código.
+          int v = 0;
+          if (elemento.compareTo(adaptador.elemento) < 0) {
+            v = -1;
+          } else if (elemento.compareTo(adaptador.elemento) > 0) {
+            v = 1;
+          }
+          return v;
         }
     }
 
@@ -74,7 +85,7 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * pero se ofrece este constructor por completez.
      */
     public MonticuloMinimo() {
-        // Aquí va su código.
+      arbol = nuevoArreglo(100);
     }
 
     /**
@@ -86,7 +97,17 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      *                  montículo.
      */
     public MonticuloMinimo(Coleccion<T> coleccion) {
-        // Aquí va su código.
+      arbol = nuevoArreglo(coleccion.getElementos());
+      elementos = coleccion.getElementos();
+      int j = 0;
+      for(T e : coleccion){
+        arbol[j] = e;
+        arbol[j].setIndice(j);
+        j++;
+      }
+      for(int i = (elementos - 1)/2; i >= 0; i--){
+        paraAbajo(i);
+      }
     }
 
     /**
@@ -99,24 +120,76 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @param n el número de elementos en el iterable.
      */
     public MonticuloMinimo(Iterable<T> iterable, int n) {
-        // Aquí va su código.
+      arbol = nuevoArreglo(n);
+      elementos = n;
+      int j = 0;
+      for(T e : iterable){
+        arbol[j] = e;
+        arbol[j].setIndice(j);
+        j++;
+      }
+      for(int i = (elementos - 1)/2; i >= 0; i--){
+        paraAbajo(i);
+      }
     }
 
+
     /**
      * Agrega un nuevo elemento en el montículo.
      * @param elemento el elemento a agregar en el montículo.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+      T[] tree;
+      if (elementos >= arbol.length) {
+            tree = nuevoArreglo(arbol.length * 2);
+            for (int i = 0; i < arbol.length; i++) {
+                tree[i] = arbol[i];
+            }
+            arbol = tree;
+      }
+      arbol[elementos] = elemento;
+      arbol[elementos].setIndice(elementos);
+      paraArriba(elementos);
+      elementos++;
     }
 
     /**
+     * Metodo para recorrer hacia arriba en el monticulo
+     * @param i indice
+     */
+     private void paraArriba(int i){
+       int ind = (i - 1)/2;
+       int m = i;
+       if (ind >= 0 && arbol[ind].compareTo(arbol[i]) > 0) {
+         m = ind;
+       }
+       if (m != i) {
+         T aux = arbol[i];
+         arbol[i] = arbol[ind];
+         arbol[i].setIndice(i);
+         arbol[ind] = aux;
+         arbol[ind].setIndice(ind);
+         paraArriba(m);
+       }
+     }
+
+    /**
      * Elimina el elemento mínimo del montículo.
      * @return el elemento mínimo del montículo.
      * @throws IllegalStateException si el montículo es vacío.
      */
     @Override public T elimina() {
-        // Aquí va su código.
+      if (elementos == 0) {
+        throw new IllegalStateException();
+      }
+      T min = arbol[0];
+      arbol[0] = arbol[--elementos];
+      arbol[0].setIndice(0);
+      arbol[elementos] = min;
+      arbol[elementos].setIndice(-1);
+      arbol[elementos] = null;
+      paraAbajo(0);
+      return min;
     }
 
     /**
@@ -124,17 +197,73 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @param elemento a eliminar del montículo.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+      if (elemento == null) {
+        return;
+      }
+      int index = elemento.getIndice();
+      T ind = arbol[index];
+      arbol[index] = arbol[--elementos];
+      arbol[index].setIndice(index);
+      arbol[elementos] = ind;
+      arbol[elementos].setIndice(-1);
+      arbol[elementos] = null;
+      reordena(arbol[index]);
     }
 
     /**
+     * Metodo para recorrer hacia abajo el monticulo
+     * @param i indice
+     */
+     private void paraAbajo(int i){
+       int izq = (2*i) + 1;
+       int der = (2*i) + 2;
+       if (izq >= getElementos() && der >= getElementos()) {
+         return;
+       }
+       int m = menor(izq, der);
+       m = menor(i, m);
+       if (m != i) {
+         T aux = arbol[i];
+         arbol[i] = arbol[m];
+         arbol[i].setIndice(i);
+         arbol[m] = aux;
+         arbol[m].setIndice(m);
+         paraAbajo(m);
+       }
+     }
+
+     /**
+      * Metodo para obtener el menor de dos indices
+      * @param a indice a comparar
+      * @param b indice a comparar
+      * @return int - el indice menor
+      */
+     private int menor(int a, int b){
+       if (b >= elementos) {
+         return a;
+       } else if (arbol[a].compareTo(arbol[b]) < 0){
+        return a;
+       }
+       return b;
+     }
+
+    /**
      * Nos dice si un elemento está contenido en el montículo.
      * @param elemento el elemento que queremos saber si está contenido.
      * @return <code>true</code> si el elemento está contenido,
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+      boolean contenido = false;
+      for (T elem : arbol) {
+        if (elem == null) {
+          contenido = false;
+        }
+        if (elem.equals(elemento)) {
+          contenido = true;
+        }
+      }
+      return contenido;
     }
 
     /**
@@ -143,14 +272,20 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      *         <tt>false</tt> en otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+      if (elementos == 0) {
+        return true;
+      }
+      return false;
     }
 
     /**
      * Limpia el montículo de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        elementos = 0;
+        for (int i = 0; i < arbol.length; i++) {
+          arbol[i] = null;
+        }
     }
 
    /**
@@ -158,7 +293,12 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @param elemento el elemento que hay que reordenar.
      */
     @Override public void reordena(T elemento) {
-        // Aquí va su código.
+      if (elemento == null) {
+        return;
+      }
+      int index = elemento.getIndice();
+      paraArriba(index);
+      paraAbajo(index);
     }
 
     /**
@@ -166,7 +306,7 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @return el número de elementos en el montículo mínimo.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+	     return elementos;
     }
 
     /**
@@ -177,7 +317,10 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      *         que el número de elementos.
      */
     @Override public T get(int i) {
-        // Aquí va su código.
+      if (i < 0 || i >= getElementos()) {
+        throw new NoSuchElementException();
+      }
+      return arbol[i];
     }
 
     /**
@@ -185,7 +328,11 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @return una representación en cadena del montículo mínimo.
      */
     @Override public String toString() {
-        // Aquí va su código.
+      String s = "";
+      for (int i = 0; i < arbol.length; i++) {
+        s += arbol[i] + ", ";
+      }
+      return s;
     }
 
     /**
@@ -197,9 +344,17 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
     @Override public boolean equals(Object o) {
         if (o == null || getClass() != o.getClass())
             return false;
-        @SuppressWarnings("unchecked") MonticuloMinimo<T> monticulo =
-            (MonticuloMinimo<T>)o;
-        // Aquí va su código.
+        @SuppressWarnings("unchecked") MonticuloMinimo<T> monticulo = (MonticuloMinimo<T>)o;
+        boolean iguales = false;
+        if (elementos == monticulo.getElementos()) {
+          for (int i = 0; i < elementos; i++) {
+            if (!arbol[i].equals(monticulo.arbol[i])) {
+              iguales = false;
+            }
+          }
+          iguales = true;
+        }
+        return iguales;
     }
 
     /**
@@ -217,8 +372,21 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @param coleccion la colección a ordenar.
      * @return una lista ordenada con los elementos de la colección.
      */
-    public static <T extends Comparable<T>>
-    Lista<T> heapSort(Coleccion<T> coleccion) {
-        // Aquí va su código.
+    public static <T extends Comparable<T>> Lista<T> heapSort(Coleccion<T> coleccion) {
+      Lista<Adaptador<T>> lista1 = new Lista<>();
+      Lista<T> lista2 = new Lista<>();
+      for (T elemento : coleccion) {
+        lista1.agrega(new Adaptador<>(elemento));
+      }
+      MonticuloMinimo<Adaptador<T>> monticulo = new MonticuloMinimo<>();
+      for (Adaptador<T> adaptador : lista1) {
+        monticulo.agrega(adaptador);
+      }
+      while (!monticulo.esVacia()) {
+        Adaptador<T> ada = monticulo.elimina();
+        lista2.agrega(ada.elemento);
+      }
+      return lista2;
     }
+
 }
diff --git a/src/mx/unam/ciencias/edd/Pila.java b/src/mx/unam/ciencias/edd/Pila.java
index fc800e7..546d931 100644
--- a/src/mx/unam/ciencias/edd/Pila.java
+++ b/src/mx/unam/ciencias/edd/Pila.java
@@ -10,7 +10,13 @@ public class Pila<T> extends MeteSaca<T> {
      * @return una representación en cadena de la pila.
      */
     @Override public String toString() {
-        // Aquí va su código.
+         Nodo nodo = cabeza;
+         String r = "";
+         while (nodo != null) {
+           r += nodo.elemento + "\n";
+           nodo = nodo.siguiente;
+         }
+         return r;
     }
 
     /**
@@ -19,7 +25,16 @@ public class Pila<T> extends MeteSaca<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    @Override public void mete(T elemento) {
-        // Aquí va su código.
+    @Override public void mete(T elemento) throws IllegalArgumentException{
+        if (elemento == null) {
+          throw new IllegalArgumentException("Elemento nulo");
+        }
+        Nodo nodo = new Nodo(elemento);
+        if (cabeza == null) {
+          cabeza = rabo = nodo;
+        } else {
+          nodo.siguiente = cabeza;
+          cabeza = nodo;
+        }
     }
 }
